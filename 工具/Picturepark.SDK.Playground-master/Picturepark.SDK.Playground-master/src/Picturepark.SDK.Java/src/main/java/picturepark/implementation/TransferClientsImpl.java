/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package picturepark.implementation;

import retrofit2.Retrofit;
import picturepark.TransferClients;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;

import okhttp3.MediaType;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import picturepark.models.Blacklist;
import picturepark.models.CreateTransferRequest;
import picturepark.models.FileTransfer2ContentCreateRequest;
import picturepark.models.FileTransferDeleteRequest;
import picturepark.models.FileTransferDetail;
import picturepark.models.FileTransferPartial2ContentCreateRequest;
import picturepark.models.FileTransferSearchRequest;
import picturepark.models.FileTransferSearchResult;
import picturepark.models.Transfer;
import picturepark.models.TransferDetail;
import picturepark.models.TransferSearchRequest;
import picturepark.models.TransferSearchResult;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Multipart;
import retrofit2.http.Part;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in TransferClients.
 */
public class TransferClientsImpl implements TransferClients {
    /** The Retrofit service to perform REST calls. */
    private TransferClientsService service;
    /** The service client containing this operation class. */
    private PictureparkAPIV1Impl client;

    /**
     * Initializes an instance of TransferClients.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public TransferClientsImpl(Retrofit retrofit, PictureparkAPIV1Impl client) {
        this.service = retrofit.create(TransferClientsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for TransferClients to be
     * used by Retrofit to perform actually REST calls.
     */
    interface TransferClientsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients get" })
        @GET("v1/transfers/{transferId}")
        Observable<Response<ResponseBody>> get(@Path("transferId") String transferId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients delete" })
        @HTTP(path = "v1/transfers/{transferId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("transferId") String transferId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients search" })
        @POST("v1/transfers/search")
        Observable<Response<ResponseBody>> search(@Body TransferSearchRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients cancelTransfer" })
        @GET("v1/transfers/{transferId}/cancel")
        Observable<Response<ResponseBody>> cancelTransfer(@Path("transferId") String transferId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients create" })
        @POST("v1/transfers")
        Observable<Response<ResponseBody>> create(@Body CreateTransferRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients getFile" })
        @GET("v1/transfers/files/{fileTransferId}")
        Observable<Response<ResponseBody>> getFile(@Path("fileTransferId") String fileTransferId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients searchFiles" })
        @POST("v1/transfers/files/search")
        Observable<Response<ResponseBody>> searchFiles(@Body FileTransferSearchRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients getBlacklist" })
        @GET("v1/transfers/files/blacklist")
        Observable<Response<ResponseBody>> getBlacklist();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients deleteFiles" })
        @POST("v1/transfers/files/delete")
        Observable<Response<ResponseBody>> deleteFiles(@Body FileTransferDeleteRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients importTransfer" })
        @POST("v1/transfers/{transferId}/import")
        Observable<Response<ResponseBody>> importTransfer(@Path("transferId") String transferId, @Body FileTransfer2ContentCreateRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.TransferClients partialImport" })
        @POST("v1/transfers/{transferId}/partialImport")
        Observable<Response<ResponseBody>> partialImport(@Path("transferId") String transferId, @Body FileTransferPartial2ContentCreateRequest request);

        @Multipart
        @POST("v1/transfers/{transferId}/files/{identifier}/upload")
        Observable<Response<ResponseBody>> uploadFile(@Path("transferId") String transferId, @Path("identifier") String identifier, @Part("formFile") RequestBody formFile, @Query("relativePath") String relativePath, @Query("chunkNumber") String chunkNumber, @Query("currentChunkSize") String currentChunkSize, @Query("totalSize") String totalSize, @Query("totalChunks") String totalChunks);

    }

    /**
     * Get Transferdetail.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransferDetail object if successful.
     */
    public TransferDetail get(String transferId) {
        return getWithServiceResponseAsync(transferId).toBlocking().single().body();
    }

    /**
     * Get Transferdetail.
     *
     * @param transferId The tranfer id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransferDetail> getAsync(String transferId, final ServiceCallback<TransferDetail> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(transferId), serviceCallback);
    }

    /**
     * Get Transferdetail.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransferDetail object
     */
    public Observable<TransferDetail> getAsync(String transferId) {
        return getWithServiceResponseAsync(transferId).map(new Func1<ServiceResponse<TransferDetail>, TransferDetail>() {
            // @Override
            public TransferDetail call(ServiceResponse<TransferDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Transferdetail.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransferDetail object
     */
    public Observable<ServiceResponse<TransferDetail>> getWithServiceResponseAsync(String transferId) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        return service.get(transferId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransferDetail>>>() {
                // @Override
                public Observable<ServiceResponse<TransferDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransferDetail> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransferDetail> getDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TransferDetail, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TransferDetail>() { }.getType())
                .build(response);
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String transferId) {
        deleteWithServiceResponseAsync(transferId).toBlocking().single().body();
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String transferId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(transferId), serviceCallback);
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String transferId) {
        return deleteWithServiceResponseAsync(transferId).map(new Func1<ServiceResponse<Void>, Void>() {
            // @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String transferId) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        return service.delete(transferId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                // @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Search.
     *
     * @param request The transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransferSearchResult object if successful.
     */
    public TransferSearchResult search(TransferSearchRequest request) {
        return searchWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Search.
     *
     * @param request The transfer search request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransferSearchResult> searchAsync(TransferSearchRequest request, final ServiceCallback<TransferSearchResult> serviceCallback) {
        return ServiceFuture.fromResponse(searchWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Search.
     *
     * @param request The transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransferSearchResult object
     */
    public Observable<TransferSearchResult> searchAsync(TransferSearchRequest request) {
        return searchWithServiceResponseAsync(request).map(new Func1<ServiceResponse<TransferSearchResult>, TransferSearchResult>() {
            // @Override
            public TransferSearchResult call(ServiceResponse<TransferSearchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * Search.
     *
     * @param request The transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransferSearchResult object
     */
    public Observable<ServiceResponse<TransferSearchResult>> searchWithServiceResponseAsync(TransferSearchRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.search(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransferSearchResult>>>() {
                // @Override
                public Observable<ServiceResponse<TransferSearchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransferSearchResult> clientResponse = searchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransferSearchResult> searchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TransferSearchResult, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TransferSearchResult>() { }.getType())
                .build(response);
    }

    /**
     * Cancels a transfer.
     *
     * @param transferId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void cancelTransfer(String transferId) {
        cancelTransferWithServiceResponseAsync(transferId).toBlocking().single().body();
    }

    /**
     * Cancels a transfer.
     *
     * @param transferId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> cancelTransferAsync(String transferId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(cancelTransferWithServiceResponseAsync(transferId), serviceCallback);
    }

    /**
     * Cancels a transfer.
     *
     * @param transferId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> cancelTransferAsync(String transferId) {
        return cancelTransferWithServiceResponseAsync(transferId).map(new Func1<ServiceResponse<Void>, Void>() {
            // @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancels a transfer.
     *
     * @param transferId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> cancelTransferWithServiceResponseAsync(String transferId) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        return service.cancelTransfer(transferId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                // @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = cancelTransferDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> cancelTransferDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Create Transfer.
     *
     * @param request The create transfer request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Transfer object if successful.
     */
    public Transfer create(CreateTransferRequest request) {
        return createWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Create Transfer.
     *
     * @param request The create transfer request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Transfer> createAsync(CreateTransferRequest request, final ServiceCallback<Transfer> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Create Transfer.
     *
     * @param request The create transfer request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Transfer object
     */
    public Observable<Transfer> createAsync(CreateTransferRequest request) {
        return createWithServiceResponseAsync(request).map(new Func1<ServiceResponse<Transfer>, Transfer>() {
            // @Override
            public Transfer call(ServiceResponse<Transfer> response) {
                return response.body();
            }
        });
    }

    /**
     * Create Transfer.
     *
     * @param request The create transfer request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Transfer object
     */
    public Observable<ServiceResponse<Transfer>> createWithServiceResponseAsync(CreateTransferRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.create(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Transfer>>>() {
                // @Override
                public Observable<ServiceResponse<Transfer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Transfer> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Transfer> createDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Transfer, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Transfer>() { }.getType())
                .build(response);
    }

    /**
     * Get File.
     *
     * @param fileTransferId The filetransfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FileTransferDetail object if successful.
     */
    public FileTransferDetail getFile(String fileTransferId) {
        return getFileWithServiceResponseAsync(fileTransferId).toBlocking().single().body();
    }

    /**
     * Get File.
     *
     * @param fileTransferId The filetransfer id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FileTransferDetail> getFileAsync(String fileTransferId, final ServiceCallback<FileTransferDetail> serviceCallback) {
        return ServiceFuture.fromResponse(getFileWithServiceResponseAsync(fileTransferId), serviceCallback);
    }

    /**
     * Get File.
     *
     * @param fileTransferId The filetransfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FileTransferDetail object
     */
    public Observable<FileTransferDetail> getFileAsync(String fileTransferId) {
        return getFileWithServiceResponseAsync(fileTransferId).map(new Func1<ServiceResponse<FileTransferDetail>, FileTransferDetail>() {
            // @Override
            public FileTransferDetail call(ServiceResponse<FileTransferDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Get File.
     *
     * @param fileTransferId The filetransfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FileTransferDetail object
     */
    public Observable<ServiceResponse<FileTransferDetail>> getFileWithServiceResponseAsync(String fileTransferId) {
        if (fileTransferId == null) {
            throw new IllegalArgumentException("Parameter fileTransferId is required and cannot be null.");
        }
        return service.getFile(fileTransferId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileTransferDetail>>>() {
                // @Override
                public Observable<ServiceResponse<FileTransferDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileTransferDetail> clientResponse = getFileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FileTransferDetail> getFileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FileTransferDetail, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FileTransferDetail>() { }.getType())
                .build(response);
    }

    /**
     * Search for files.
     *
     * @param request The file transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FileTransferSearchResult object if successful.
     */
    public FileTransferSearchResult searchFiles(FileTransferSearchRequest request) {
        return searchFilesWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Search for files.
     *
     * @param request The file transfer search request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FileTransferSearchResult> searchFilesAsync(FileTransferSearchRequest request, final ServiceCallback<FileTransferSearchResult> serviceCallback) {
        return ServiceFuture.fromResponse(searchFilesWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Search for files.
     *
     * @param request The file transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FileTransferSearchResult object
     */
    public Observable<FileTransferSearchResult> searchFilesAsync(FileTransferSearchRequest request) {
        return searchFilesWithServiceResponseAsync(request).map(new Func1<ServiceResponse<FileTransferSearchResult>, FileTransferSearchResult>() {
            // @Override
            public FileTransferSearchResult call(ServiceResponse<FileTransferSearchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * Search for files.
     *
     * @param request The file transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FileTransferSearchResult object
     */
    public Observable<ServiceResponse<FileTransferSearchResult>> searchFilesWithServiceResponseAsync(FileTransferSearchRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.searchFiles(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileTransferSearchResult>>>() {
                // @Override
                public Observable<ServiceResponse<FileTransferSearchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileTransferSearchResult> clientResponse = searchFilesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FileTransferSearchResult> searchFilesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FileTransferSearchResult, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FileTransferSearchResult>() { }.getType())
                .build(response);
    }

    /**
     * Get Blacklist.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Blacklist object if successful.
     */
    public Blacklist getBlacklist() {
        return getBlacklistWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get Blacklist.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Blacklist> getBlacklistAsync(final ServiceCallback<Blacklist> serviceCallback) {
        return ServiceFuture.fromResponse(getBlacklistWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get Blacklist.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Blacklist object
     */
    public Observable<Blacklist> getBlacklistAsync() {
        return getBlacklistWithServiceResponseAsync().map(new Func1<ServiceResponse<Blacklist>, Blacklist>() {
            // @Override
            public Blacklist call(ServiceResponse<Blacklist> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Blacklist.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Blacklist object
     */
    public Observable<ServiceResponse<Blacklist>> getBlacklistWithServiceResponseAsync() {
        return service.getBlacklist()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Blacklist>>>() {
                // @Override
                public Observable<ServiceResponse<Blacklist>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Blacklist> clientResponse = getBlacklistDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Blacklist> getBlacklistDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.client.restClient().responseBuilderFactory().<Blacklist, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Blacklist>() { }.getType())
                .build(response);
    }

    /**
     * Delete Files.
     *
     * @param request The filetransfer delete request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteFiles(FileTransferDeleteRequest request) {
        deleteFilesWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Delete Files.
     *
     * @param request The filetransfer delete request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteFilesAsync(FileTransferDeleteRequest request, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteFilesWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Delete Files.
     *
     * @param request The filetransfer delete request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteFilesAsync(FileTransferDeleteRequest request) {
        return deleteFilesWithServiceResponseAsync(request).map(new Func1<ServiceResponse<Void>, Void>() {
            // @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete Files.
     *
     * @param request The filetransfer delete request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteFilesWithServiceResponseAsync(FileTransferDeleteRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.deleteFiles(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                // @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteFilesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteFilesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Import transfer.
     *
     * @param transferId The tranfer id
     * @param request The filetransfer to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Transfer object if successful.
     */
    public Transfer importTransfer(String transferId, FileTransfer2ContentCreateRequest request) {
        return importTransferWithServiceResponseAsync(transferId, request).toBlocking().single().body();
    }

    /**
     * Import transfer.
     *
     * @param transferId The tranfer id
     * @param request The filetransfer to content create request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Transfer> importTransferAsync(String transferId, FileTransfer2ContentCreateRequest request, final ServiceCallback<Transfer> serviceCallback) {
        return ServiceFuture.fromResponse(importTransferWithServiceResponseAsync(transferId, request), serviceCallback);
    }

    /**
     * Import transfer.
     *
     * @param transferId The tranfer id
     * @param request The filetransfer to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Transfer object
     */
    public Observable<Transfer> importTransferAsync(String transferId, FileTransfer2ContentCreateRequest request) {
        return importTransferWithServiceResponseAsync(transferId, request).map(new Func1<ServiceResponse<Transfer>, Transfer>() {
            // @Override
            public Transfer call(ServiceResponse<Transfer> response) {
                return response.body();
            }
        });
    }

    /**
     * Import transfer.
     *
     * @param transferId The tranfer id
     * @param request The filetransfer to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Transfer object
     */
    public Observable<ServiceResponse<Transfer>> importTransferWithServiceResponseAsync(String transferId, FileTransfer2ContentCreateRequest request) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.importTransfer(transferId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Transfer>>>() {
                // @Override
                public Observable<ServiceResponse<Transfer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Transfer> clientResponse = importTransferDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Transfer> importTransferDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Transfer, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Transfer>() { }.getType())
                .build(response);
    }

    /**
     * Create a partial import.
     *
     * @param transferId The transfer id
     * @param request The filetransfer partial to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Transfer object if successful.
     */
    public Transfer partialImport(String transferId, FileTransferPartial2ContentCreateRequest request) {
        return partialImportWithServiceResponseAsync(transferId, request).toBlocking().single().body();
    }

    /**
     * Create a partial import.
     *
     * @param transferId The transfer id
     * @param request The filetransfer partial to content create request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Transfer> partialImportAsync(String transferId, FileTransferPartial2ContentCreateRequest request, final ServiceCallback<Transfer> serviceCallback) {
        return ServiceFuture.fromResponse(partialImportWithServiceResponseAsync(transferId, request), serviceCallback);
    }

    /**
     * Create a partial import.
     *
     * @param transferId The transfer id
     * @param request The filetransfer partial to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Transfer object
     */
    public Observable<Transfer> partialImportAsync(String transferId, FileTransferPartial2ContentCreateRequest request) {
        return partialImportWithServiceResponseAsync(transferId, request).map(new Func1<ServiceResponse<Transfer>, Transfer>() {
            // @Override
            public Transfer call(ServiceResponse<Transfer> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a partial import.
     *
     * @param transferId The transfer id
     * @param request The filetransfer partial to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Transfer object
     */
    public Observable<ServiceResponse<Transfer>> partialImportWithServiceResponseAsync(String transferId, FileTransferPartial2ContentCreateRequest request) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.partialImport(transferId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Transfer>>>() {
                // @Override
                public Observable<ServiceResponse<Transfer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Transfer> clientResponse = partialImportDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Transfer> partialImportDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Transfer, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Transfer>() { }.getType())
                .build(response);
    }

    /**
     * Upload file.
     *
     * @param transferId the String value
     * @param identifier the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void uploadFile(String transferId, String identifier) {
        uploadFileWithServiceResponseAsync(transferId, identifier).toBlocking().single().body();
    }

    /**
     * Upload file.
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> uploadFileAsync(String transferId, String identifier, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(uploadFileWithServiceResponseAsync(transferId, identifier), serviceCallback);
    }

    /**
     * Upload file.
     *
     * @param transferId the String value
     * @param identifier the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> uploadFileAsync(String transferId, String identifier) {
        return uploadFileWithServiceResponseAsync(transferId, identifier).map(new Func1<ServiceResponse<Void>, Void>() {
            // @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Upload file.
     *
     * @param transferId the String value
     * @param identifier the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> uploadFileWithServiceResponseAsync(String transferId, String identifier) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        if (identifier == null) {
            throw new IllegalArgumentException("Parameter identifier is required and cannot be null.");
        }
        final byte[] formFile = new byte[0];
        final String relativePath = null;
        final String chunkNumber = null;
        final String currentChunkSize = null;
        final String totalSize = null;
        final String totalChunks = null;
        RequestBody formFileConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (formFile != null) {
            formFileConverted = RequestBody.create(MediaType.parse("multipart/form-data"), formFile);
        }
        return service.uploadFile(transferId, identifier, formFileConverted, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                // @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = uploadFileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Upload file.
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param formFile Gets or sets the form file.
     * @param relativePath Relative path of the uploading file
     * @param chunkNumber Current chunk number. starts with 1
     * @param currentChunkSize Size in bytes of the current chunk
     * @param totalSize Total size in bytes of the uploading file
     * @param totalChunks Total chunks of the uploading file
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void uploadFile(String transferId, String identifier, byte[] formFile, String relativePath, String chunkNumber, String currentChunkSize, String totalSize, String totalChunks) {
        uploadFileWithServiceResponseAsync(transferId, identifier, formFile, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks).toBlocking().single().body();
    }

    /**
     * Upload file.
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param formFile Gets or sets the form file.
     * @param relativePath Relative path of the uploading file
     * @param chunkNumber Current chunk number. starts with 1
     * @param currentChunkSize Size in bytes of the current chunk
     * @param totalSize Total size in bytes of the uploading file
     * @param totalChunks Total chunks of the uploading file
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> uploadFileAsync(String transferId, String identifier, byte[] formFile, String relativePath, String chunkNumber, String currentChunkSize, String totalSize, String totalChunks, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(uploadFileWithServiceResponseAsync(transferId, identifier, formFile, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks), serviceCallback);
    }

    /**
     * Upload file.
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param formFile Gets or sets the form file.
     * @param relativePath Relative path of the uploading file
     * @param chunkNumber Current chunk number. starts with 1
     * @param currentChunkSize Size in bytes of the current chunk
     * @param totalSize Total size in bytes of the uploading file
     * @param totalChunks Total chunks of the uploading file
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> uploadFileAsync(String transferId, String identifier, byte[] formFile, String relativePath, String chunkNumber, String currentChunkSize, String totalSize, String totalChunks) {
        return uploadFileWithServiceResponseAsync(transferId, identifier, formFile, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks).map(new Func1<ServiceResponse<Void>, Void>() {
            // @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Upload file.
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param formFile Gets or sets the form file.
     * @param relativePath Relative path of the uploading file
     * @param chunkNumber Current chunk number. starts with 1
     * @param currentChunkSize Size in bytes of the current chunk
     * @param totalSize Total size in bytes of the uploading file
     * @param totalChunks Total chunks of the uploading file
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> uploadFileWithServiceResponseAsync(String transferId, String identifier, byte[] formFile, String relativePath, String chunkNumber, String currentChunkSize, String totalSize, String totalChunks) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        if (identifier == null) {
            throw new IllegalArgumentException("Parameter identifier is required and cannot be null.");
        }
        RequestBody formFileConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (formFile != null) {
            formFileConverted = RequestBody.create(MediaType.parse("multipart/form-data"), formFile);
        }
        return service.uploadFile(transferId, identifier, formFileConverted, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                // @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = uploadFileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> uploadFileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

}
