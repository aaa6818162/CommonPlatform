/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package picturepark.implementation;

import retrofit2.Retrofit;
import picturepark.ListItemClients;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import picturepark.models.BusinessProcess;
import picturepark.models.ListItemAggregationRequest;
import picturepark.models.ListItemCreateManyRequest;
import picturepark.models.ListItemCreateRequest;
import picturepark.models.ListItemDeactivateRequest;
import picturepark.models.ListItemDetail;
import picturepark.models.ListItemFieldsFilterUpdateRequest;
import picturepark.models.ListItemFieldsUpdateRequest;
import picturepark.models.ListItemReactivateRequest;
import picturepark.models.ListItemReferences;
import picturepark.models.ListItemSearchRequest;
import picturepark.models.ListItemSearchResult;
import picturepark.models.ListItemUpdateManyRequest;
import picturepark.models.ListItemUpdateRequest;
import picturepark.models.ObjectAggregationResult;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in ListItemClients.
 */
public class ListItemClientsImpl implements ListItemClients {
    /** The Retrofit service to perform REST calls. */
    private ListItemClientsService service;
    /** The service client containing this operation class. */
    private PictureparkAPIV1Impl client;

    /**
     * Initializes an instance of ListItemClients.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ListItemClientsImpl(Retrofit retrofit, PictureparkAPIV1Impl client) {
        this.service = retrofit.create(ListItemClientsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for ListItemClients to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ListItemClientsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients get" })
        @GET("v1/listItems/{listItemId}")
        Observable<Response<ResponseBody>> get(@Path("listItemId") String listItemId, @Query("resolve") String resolve, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients update" })
        @PUT("v1/listItems/{listItemId}")
        Observable<Response<ResponseBody>> update(@Path("listItemId") String listItemId, @Body ListItemUpdateRequest updateRequest, @Query("resolve") String resolve, @Query("allowMissingDependencies") String allowMissingDependencies, @Query("timeout") String timeout, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients search" })
        @POST("v1/listItems/search")
        Observable<Response<ResponseBody>> search(@Body ListItemSearchRequest listItemSearchRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients aggregate" })
        @POST("v1/listItems/aggregate")
        Observable<Response<ResponseBody>> aggregate(@Body ListItemAggregationRequest listItemAggregationRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients create" })
        @POST("v1/listItems")
        Observable<Response<ResponseBody>> create(@Body ListItemCreateRequest listItemCreateRequest, @Query("resolve") String resolve, @Query("allowMissingDependencies") String allowMissingDependencies, @Query("timeout") String timeout, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients createMany" })
        @POST("v1/listItems/many")
        Observable<Response<ResponseBody>> createMany(@Body ListItemCreateManyRequest listItemCreateManyRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients updateMany" })
        @PUT("v1/listItems/many")
        Observable<Response<ResponseBody>> updateMany(@Body ListItemUpdateManyRequest listItemUpdateManyRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients deactivate" })
        @PUT("v1/listItems/{listItemId}/deactivate")
        Observable<Response<ResponseBody>> deactivate(@Path("listItemId") String listItemId, @Query("timeout") String timeout, @Query("forceReferenceRemoval") String forceReferenceRemoval);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients deactivateMany" })
        @PUT("v1/listItems/many/deactivate")
        Observable<Response<ResponseBody>> deactivateMany(@Body ListItemDeactivateRequest deactivateRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients reactivate" })
        @PUT("v1/listItems/{listItemId}/reactivate")
        Observable<Response<ResponseBody>> reactivate(@Path("listItemId") String listItemId, @Query("timeout") String timeout, @Query("patterns") String patterns, @Query("allowMissingDependencies") String allowMissingDependencies);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients reactivateMany" })
        @PUT("v1/listItems/many/reactivate")
        Observable<Response<ResponseBody>> reactivateMany(@Body ListItemReactivateRequest reactivateRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients batchUpdateFieldsByIds" })
        @PUT("v1/listItems/batches/fields/ids")
        Observable<Response<ResponseBody>> batchUpdateFieldsByIds(@Body ListItemFieldsUpdateRequest updateRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients batchUpdateFieldsByFilter" })
        @PUT("v1/listItems/batches/fields/filter")
        Observable<Response<ResponseBody>> batchUpdateFieldsByFilter(@Body ListItemFieldsFilterUpdateRequest updateRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients getReferencesToListItem" })
        @GET("v1/listItems/{listItemId}/references")
        Observable<Response<ResponseBody>> getReferencesToListItem(@Path("listItemId") String listItemId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItemClients getReferencesToListItems" })
        @GET("v1/listItems/many/references")
        Observable<Response<ResponseBody>> getReferencesToListItems(@Query("ids") String ids);

    }

    /**
     * Get - single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail get(String listItemId, String resolve) {
        return getWithServiceResponseAsync(listItemId, resolve).toBlocking().single().body();
    }

    /**
     * Get - single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> getAsync(String listItemId, String resolve, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(listItemId, resolve), serviceCallback);
    }

    /**
     * Get - single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> getAsync(String listItemId, String resolve) {
        return getWithServiceResponseAsync(listItemId, resolve).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Get - single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> getWithServiceResponseAsync(String listItemId, String resolve) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        if (resolve == null) {
            throw new IllegalArgumentException("Parameter resolve is required and cannot be null.");
        }
        final String patterns = null;
        return service.get(listItemId, resolve, patterns)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get - single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail get(String listItemId, String resolve, String patterns) {
        return getWithServiceResponseAsync(listItemId, resolve, patterns).toBlocking().single().body();
    }

    /**
     * Get - single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> getAsync(String listItemId, String resolve, String patterns, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(listItemId, resolve, patterns), serviceCallback);
    }

    /**
     * Get - single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> getAsync(String listItemId, String resolve, String patterns) {
        return getWithServiceResponseAsync(listItemId, resolve, patterns).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Get - single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> getWithServiceResponseAsync(String listItemId, String resolve, String patterns) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        if (resolve == null) {
            throw new IllegalArgumentException("Parameter resolve is required and cannot be null.");
        }
        return service.get(listItemId, resolve, patterns)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ListItemDetail> getDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListItemDetail, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemDetail>() { }.getType())
                .build(response);
    }

    /**
     * Update - single.
     * Updates a single list item.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail update(String listItemId, ListItemUpdateRequest updateRequest, String resolve) {
        return updateWithServiceResponseAsync(listItemId, updateRequest, resolve).toBlocking().single().body();
    }

    /**
     * Update - single.
     * Updates a single list item.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> updateAsync(String listItemId, ListItemUpdateRequest updateRequest, String resolve, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(listItemId, updateRequest, resolve), serviceCallback);
    }

    /**
     * Update - single.
     * Updates a single list item.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> updateAsync(String listItemId, ListItemUpdateRequest updateRequest, String resolve) {
        return updateWithServiceResponseAsync(listItemId, updateRequest, resolve).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Update - single.
     * Updates a single list item.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> updateWithServiceResponseAsync(String listItemId, ListItemUpdateRequest updateRequest, String resolve) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        if (resolve == null) {
            throw new IllegalArgumentException("Parameter resolve is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        final String allowMissingDependencies = null;
        final String timeout = null;
        final String patterns = null;
        return service.update(listItemId, updateRequest, resolve, allowMissingDependencies, timeout, patterns)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update - single.
     * Updates a single list item.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param allowMissingDependencies Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail update(String listItemId, ListItemUpdateRequest updateRequest, String resolve, String allowMissingDependencies, String timeout, String patterns) {
        return updateWithServiceResponseAsync(listItemId, updateRequest, resolve, allowMissingDependencies, timeout, patterns).toBlocking().single().body();
    }

    /**
     * Update - single.
     * Updates a single list item.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param allowMissingDependencies Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> updateAsync(String listItemId, ListItemUpdateRequest updateRequest, String resolve, String allowMissingDependencies, String timeout, String patterns, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(listItemId, updateRequest, resolve, allowMissingDependencies, timeout, patterns), serviceCallback);
    }

    /**
     * Update - single.
     * Updates a single list item.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param allowMissingDependencies Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> updateAsync(String listItemId, ListItemUpdateRequest updateRequest, String resolve, String allowMissingDependencies, String timeout, String patterns) {
        return updateWithServiceResponseAsync(listItemId, updateRequest, resolve, allowMissingDependencies, timeout, patterns).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Update - single.
     * Updates a single list item.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param allowMissingDependencies Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> updateWithServiceResponseAsync(String listItemId, ListItemUpdateRequest updateRequest, String resolve, String allowMissingDependencies, String timeout, String patterns) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        if (resolve == null) {
            throw new IllegalArgumentException("Parameter resolve is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.update(listItemId, updateRequest, resolve, allowMissingDependencies, timeout, patterns)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ListItemDetail> updateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListItemDetail, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemDetail>() { }.getType())
                .build(response);
    }

    /**
     * Search.
     * Searches list items as specified in the search request.
     *
     * @param listItemSearchRequest The list item search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemSearchResult object if successful.
     */
    public ListItemSearchResult search(ListItemSearchRequest listItemSearchRequest) {
        return searchWithServiceResponseAsync(listItemSearchRequest).toBlocking().single().body();
    }

    /**
     * Search.
     * Searches list items as specified in the search request.
     *
     * @param listItemSearchRequest The list item search request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemSearchResult> searchAsync(ListItemSearchRequest listItemSearchRequest, final ServiceCallback<ListItemSearchResult> serviceCallback) {
        return ServiceFuture.fromResponse(searchWithServiceResponseAsync(listItemSearchRequest), serviceCallback);
    }

    /**
     * Search.
     * Searches list items as specified in the search request.
     *
     * @param listItemSearchRequest The list item search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemSearchResult object
     */
    public Observable<ListItemSearchResult> searchAsync(ListItemSearchRequest listItemSearchRequest) {
        return searchWithServiceResponseAsync(listItemSearchRequest).map(new Func1<ServiceResponse<ListItemSearchResult>, ListItemSearchResult>() {
            // @Override
            public ListItemSearchResult call(ServiceResponse<ListItemSearchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * Search.
     * Searches list items as specified in the search request.
     *
     * @param listItemSearchRequest The list item search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemSearchResult object
     */
    public Observable<ServiceResponse<ListItemSearchResult>> searchWithServiceResponseAsync(ListItemSearchRequest listItemSearchRequest) {
        if (listItemSearchRequest == null) {
            throw new IllegalArgumentException("Parameter listItemSearchRequest is required and cannot be null.");
        }
        Validator.validate(listItemSearchRequest);
        return service.search(listItemSearchRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemSearchResult>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemSearchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemSearchResult> clientResponse = searchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ListItemSearchResult> searchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListItemSearchResult, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemSearchResult>() { }.getType())
                .build(response);
    }

    /**
     * Aggregate.
     * Aggregates list items as specified in the aggregation request.
     *
     * @param listItemAggregationRequest The list item aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ObjectAggregationResult object if successful.
     */
    public ObjectAggregationResult aggregate(ListItemAggregationRequest listItemAggregationRequest) {
        return aggregateWithServiceResponseAsync(listItemAggregationRequest).toBlocking().single().body();
    }

    /**
     * Aggregate.
     * Aggregates list items as specified in the aggregation request.
     *
     * @param listItemAggregationRequest The list item aggregation request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ObjectAggregationResult> aggregateAsync(ListItemAggregationRequest listItemAggregationRequest, final ServiceCallback<ObjectAggregationResult> serviceCallback) {
        return ServiceFuture.fromResponse(aggregateWithServiceResponseAsync(listItemAggregationRequest), serviceCallback);
    }

    /**
     * Aggregate.
     * Aggregates list items as specified in the aggregation request.
     *
     * @param listItemAggregationRequest The list item aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ObjectAggregationResult object
     */
    public Observable<ObjectAggregationResult> aggregateAsync(ListItemAggregationRequest listItemAggregationRequest) {
        return aggregateWithServiceResponseAsync(listItemAggregationRequest).map(new Func1<ServiceResponse<ObjectAggregationResult>, ObjectAggregationResult>() {
            // @Override
            public ObjectAggregationResult call(ServiceResponse<ObjectAggregationResult> response) {
                return response.body();
            }
        });
    }

    /**
     * Aggregate.
     * Aggregates list items as specified in the aggregation request.
     *
     * @param listItemAggregationRequest The list item aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ObjectAggregationResult object
     */
    public Observable<ServiceResponse<ObjectAggregationResult>> aggregateWithServiceResponseAsync(ListItemAggregationRequest listItemAggregationRequest) {
        if (listItemAggregationRequest == null) {
            throw new IllegalArgumentException("Parameter listItemAggregationRequest is required and cannot be null.");
        }
        Validator.validate(listItemAggregationRequest);
        return service.aggregate(listItemAggregationRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ObjectAggregationResult>>>() {
                // @Override
                public Observable<ServiceResponse<ObjectAggregationResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ObjectAggregationResult> clientResponse = aggregateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ObjectAggregationResult> aggregateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ObjectAggregationResult, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ObjectAggregationResult>() { }.getType())
                .build(response);
    }

    /**
     * Create - single.
     * Create a single list item.
     *
     * @param listItemCreateRequest List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail create(ListItemCreateRequest listItemCreateRequest, String resolve) {
        return createWithServiceResponseAsync(listItemCreateRequest, resolve).toBlocking().single().body();
    }

    /**
     * Create - single.
     * Create a single list item.
     *
     * @param listItemCreateRequest List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> createAsync(ListItemCreateRequest listItemCreateRequest, String resolve, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(listItemCreateRequest, resolve), serviceCallback);
    }

    /**
     * Create - single.
     * Create a single list item.
     *
     * @param listItemCreateRequest List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> createAsync(ListItemCreateRequest listItemCreateRequest, String resolve) {
        return createWithServiceResponseAsync(listItemCreateRequest, resolve).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Create - single.
     * Create a single list item.
     *
     * @param listItemCreateRequest List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> createWithServiceResponseAsync(ListItemCreateRequest listItemCreateRequest, String resolve) {
        if (listItemCreateRequest == null) {
            throw new IllegalArgumentException("Parameter listItemCreateRequest is required and cannot be null.");
        }
        if (resolve == null) {
            throw new IllegalArgumentException("Parameter resolve is required and cannot be null.");
        }
        Validator.validate(listItemCreateRequest);
        final String allowMissingDependencies = null;
        final String timeout = null;
        final String patterns = null;
        return service.create(listItemCreateRequest, resolve, allowMissingDependencies, timeout, patterns)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create - single.
     * Create a single list item.
     *
     * @param listItemCreateRequest List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param allowMissingDependencies Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail create(ListItemCreateRequest listItemCreateRequest, String resolve, String allowMissingDependencies, String timeout, String patterns) {
        return createWithServiceResponseAsync(listItemCreateRequest, resolve, allowMissingDependencies, timeout, patterns).toBlocking().single().body();
    }

    /**
     * Create - single.
     * Create a single list item.
     *
     * @param listItemCreateRequest List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param allowMissingDependencies Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> createAsync(ListItemCreateRequest listItemCreateRequest, String resolve, String allowMissingDependencies, String timeout, String patterns, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(listItemCreateRequest, resolve, allowMissingDependencies, timeout, patterns), serviceCallback);
    }

    /**
     * Create - single.
     * Create a single list item.
     *
     * @param listItemCreateRequest List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param allowMissingDependencies Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> createAsync(ListItemCreateRequest listItemCreateRequest, String resolve, String allowMissingDependencies, String timeout, String patterns) {
        return createWithServiceResponseAsync(listItemCreateRequest, resolve, allowMissingDependencies, timeout, patterns).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Create - single.
     * Create a single list item.
     *
     * @param listItemCreateRequest List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param allowMissingDependencies Allow creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> createWithServiceResponseAsync(ListItemCreateRequest listItemCreateRequest, String resolve, String allowMissingDependencies, String timeout, String patterns) {
        if (listItemCreateRequest == null) {
            throw new IllegalArgumentException("Parameter listItemCreateRequest is required and cannot be null.");
        }
        if (resolve == null) {
            throw new IllegalArgumentException("Parameter resolve is required and cannot be null.");
        }
        Validator.validate(listItemCreateRequest);
        return service.create(listItemCreateRequest, resolve, allowMissingDependencies, timeout, patterns)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ListItemDetail> createDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListItemDetail, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemDetail>() { }.getType())
                .build(response);
    }

    /**
     * Create - many.
     * Create multiple list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param listItemCreateManyRequest List item create many request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BusinessProcess object if successful.
     */
    public BusinessProcess createMany(ListItemCreateManyRequest listItemCreateManyRequest) {
        return createManyWithServiceResponseAsync(listItemCreateManyRequest).toBlocking().single().body();
    }

    /**
     * Create - many.
     * Create multiple list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param listItemCreateManyRequest List item create many request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BusinessProcess> createManyAsync(ListItemCreateManyRequest listItemCreateManyRequest, final ServiceCallback<BusinessProcess> serviceCallback) {
        return ServiceFuture.fromResponse(createManyWithServiceResponseAsync(listItemCreateManyRequest), serviceCallback);
    }

    /**
     * Create - many.
     * Create multiple list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param listItemCreateManyRequest List item create many request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<BusinessProcess> createManyAsync(ListItemCreateManyRequest listItemCreateManyRequest) {
        return createManyWithServiceResponseAsync(listItemCreateManyRequest).map(new Func1<ServiceResponse<BusinessProcess>, BusinessProcess>() {
            // @Override
            public BusinessProcess call(ServiceResponse<BusinessProcess> response) {
                return response.body();
            }
        });
    }

    /**
     * Create - many.
     * Create multiple list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param listItemCreateManyRequest List item create many request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<ServiceResponse<BusinessProcess>> createManyWithServiceResponseAsync(ListItemCreateManyRequest listItemCreateManyRequest) {
        if (listItemCreateManyRequest == null) {
            throw new IllegalArgumentException("Parameter listItemCreateManyRequest is required and cannot be null.");
        }
        Validator.validate(listItemCreateManyRequest);
        return service.createMany(listItemCreateManyRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BusinessProcess>>>() {
                // @Override
                public Observable<ServiceResponse<BusinessProcess>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BusinessProcess> clientResponse = createManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BusinessProcess> createManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BusinessProcess, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .build(response);
    }

    /**
     * Update - many.
     * Updates multiple list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param listItemUpdateManyRequest List item update many request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BusinessProcess object if successful.
     */
    public BusinessProcess updateMany(ListItemUpdateManyRequest listItemUpdateManyRequest) {
        return updateManyWithServiceResponseAsync(listItemUpdateManyRequest).toBlocking().single().body();
    }

    /**
     * Update - many.
     * Updates multiple list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param listItemUpdateManyRequest List item update many request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BusinessProcess> updateManyAsync(ListItemUpdateManyRequest listItemUpdateManyRequest, final ServiceCallback<BusinessProcess> serviceCallback) {
        return ServiceFuture.fromResponse(updateManyWithServiceResponseAsync(listItemUpdateManyRequest), serviceCallback);
    }

    /**
     * Update - many.
     * Updates multiple list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param listItemUpdateManyRequest List item update many request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<BusinessProcess> updateManyAsync(ListItemUpdateManyRequest listItemUpdateManyRequest) {
        return updateManyWithServiceResponseAsync(listItemUpdateManyRequest).map(new Func1<ServiceResponse<BusinessProcess>, BusinessProcess>() {
            // @Override
            public BusinessProcess call(ServiceResponse<BusinessProcess> response) {
                return response.body();
            }
        });
    }

    /**
     * Update - many.
     * Updates multiple list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param listItemUpdateManyRequest List item update many request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<ServiceResponse<BusinessProcess>> updateManyWithServiceResponseAsync(ListItemUpdateManyRequest listItemUpdateManyRequest) {
        if (listItemUpdateManyRequest == null) {
            throw new IllegalArgumentException("Parameter listItemUpdateManyRequest is required and cannot be null.");
        }
        Validator.validate(listItemUpdateManyRequest);
        return service.updateMany(listItemUpdateManyRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BusinessProcess>>>() {
                // @Override
                public Observable<ServiceResponse<BusinessProcess>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BusinessProcess> clientResponse = updateManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BusinessProcess> updateManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BusinessProcess, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .build(response);
    }

    /**
     * Deactivate - single.
     * Deactivates a single listitem. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     *
     * @param listItemId the id of the list item to deactivate
     * @param timeout Maximum time to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail deactivate(String listItemId, String timeout) {
        return deactivateWithServiceResponseAsync(listItemId, timeout).toBlocking().single().body();
    }

    /**
     * Deactivate - single.
     * Deactivates a single listitem. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     *
     * @param listItemId the id of the list item to deactivate
     * @param timeout Maximum time to wait for the business process completed state.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> deactivateAsync(String listItemId, String timeout, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(deactivateWithServiceResponseAsync(listItemId, timeout), serviceCallback);
    }

    /**
     * Deactivate - single.
     * Deactivates a single listitem. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     *
     * @param listItemId the id of the list item to deactivate
     * @param timeout Maximum time to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> deactivateAsync(String listItemId, String timeout) {
        return deactivateWithServiceResponseAsync(listItemId, timeout).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivate - single.
     * Deactivates a single listitem. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     *
     * @param listItemId the id of the list item to deactivate
     * @param timeout Maximum time to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> deactivateWithServiceResponseAsync(String listItemId, String timeout) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        if (timeout == null) {
            throw new IllegalArgumentException("Parameter timeout is required and cannot be null.");
        }
        final String forceReferenceRemoval = null;
        return service.deactivate(listItemId, timeout, forceReferenceRemoval)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = deactivateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deactivate - single.
     * Deactivates a single listitem. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     *
     * @param listItemId the id of the list item to deactivate
     * @param timeout Maximum time to wait for the business process completed state.
     * @param forceReferenceRemoval A value indicating whether references to the listitem should be removed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail deactivate(String listItemId, String timeout, String forceReferenceRemoval) {
        return deactivateWithServiceResponseAsync(listItemId, timeout, forceReferenceRemoval).toBlocking().single().body();
    }

    /**
     * Deactivate - single.
     * Deactivates a single listitem. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     *
     * @param listItemId the id of the list item to deactivate
     * @param timeout Maximum time to wait for the business process completed state.
     * @param forceReferenceRemoval A value indicating whether references to the listitem should be removed.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> deactivateAsync(String listItemId, String timeout, String forceReferenceRemoval, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(deactivateWithServiceResponseAsync(listItemId, timeout, forceReferenceRemoval), serviceCallback);
    }

    /**
     * Deactivate - single.
     * Deactivates a single listitem. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     *
     * @param listItemId the id of the list item to deactivate
     * @param timeout Maximum time to wait for the business process completed state.
     * @param forceReferenceRemoval A value indicating whether references to the listitem should be removed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> deactivateAsync(String listItemId, String timeout, String forceReferenceRemoval) {
        return deactivateWithServiceResponseAsync(listItemId, timeout, forceReferenceRemoval).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivate - single.
     * Deactivates a single listitem. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     *
     * @param listItemId the id of the list item to deactivate
     * @param timeout Maximum time to wait for the business process completed state.
     * @param forceReferenceRemoval A value indicating whether references to the listitem should be removed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> deactivateWithServiceResponseAsync(String listItemId, String timeout, String forceReferenceRemoval) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        if (timeout == null) {
            throw new IllegalArgumentException("Parameter timeout is required and cannot be null.");
        }
        return service.deactivate(listItemId, timeout, forceReferenceRemoval)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = deactivateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ListItemDetail> deactivateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListItemDetail, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemDetail>() { }.getType())
                .build(response);
    }

    /**
     * Deactivate - many.
     * Deactivates multiple list items. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param deactivateRequest The list items deactivate request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BusinessProcess object if successful.
     */
    public BusinessProcess deactivateMany(ListItemDeactivateRequest deactivateRequest) {
        return deactivateManyWithServiceResponseAsync(deactivateRequest).toBlocking().single().body();
    }

    /**
     * Deactivate - many.
     * Deactivates multiple list items. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param deactivateRequest The list items deactivate request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BusinessProcess> deactivateManyAsync(ListItemDeactivateRequest deactivateRequest, final ServiceCallback<BusinessProcess> serviceCallback) {
        return ServiceFuture.fromResponse(deactivateManyWithServiceResponseAsync(deactivateRequest), serviceCallback);
    }

    /**
     * Deactivate - many.
     * Deactivates multiple list items. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param deactivateRequest The list items deactivate request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<BusinessProcess> deactivateManyAsync(ListItemDeactivateRequest deactivateRequest) {
        return deactivateManyWithServiceResponseAsync(deactivateRequest).map(new Func1<ServiceResponse<BusinessProcess>, BusinessProcess>() {
            // @Override
            public BusinessProcess call(ServiceResponse<BusinessProcess> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivate - many.
     * Deactivates multiple list items. The lifecycle is changed to Inactive. After a customer instance specified time (default 30 days), the list item and all files will be deleted.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param deactivateRequest The list items deactivate request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<ServiceResponse<BusinessProcess>> deactivateManyWithServiceResponseAsync(ListItemDeactivateRequest deactivateRequest) {
        if (deactivateRequest == null) {
            throw new IllegalArgumentException("Parameter deactivateRequest is required and cannot be null.");
        }
        Validator.validate(deactivateRequest);
        return service.deactivateMany(deactivateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BusinessProcess>>>() {
                // @Override
                public Observable<ServiceResponse<BusinessProcess>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BusinessProcess> clientResponse = deactivateManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BusinessProcess> deactivateManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BusinessProcess, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .build(response);
    }

    /**
     * Reactivate - single.
     * Reactivate a previously deactivated list item.
     *
     * @param listItemId The list item id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail reactivate(String listItemId) {
        return reactivateWithServiceResponseAsync(listItemId).toBlocking().single().body();
    }

    /**
     * Reactivate - single.
     * Reactivate a previously deactivated list item.
     *
     * @param listItemId The list item id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> reactivateAsync(String listItemId, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(reactivateWithServiceResponseAsync(listItemId), serviceCallback);
    }

    /**
     * Reactivate - single.
     * Reactivate a previously deactivated list item.
     *
     * @param listItemId The list item id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> reactivateAsync(String listItemId) {
        return reactivateWithServiceResponseAsync(listItemId).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Reactivate - single.
     * Reactivate a previously deactivated list item.
     *
     * @param listItemId The list item id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> reactivateWithServiceResponseAsync(String listItemId) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        final String timeout = null;
        final String patterns = null;
        final String allowMissingDependencies = null;
        return service.reactivate(listItemId, timeout, patterns, allowMissingDependencies)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = reactivateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Reactivate - single.
     * Reactivate a previously deactivated list item.
     *
     * @param listItemId The list item id.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @param allowMissingDependencies Allow reactivating list items that refer to list items or contents that don't exist in the system.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemDetail object if successful.
     */
    public ListItemDetail reactivate(String listItemId, String timeout, String patterns, String allowMissingDependencies) {
        return reactivateWithServiceResponseAsync(listItemId, timeout, patterns, allowMissingDependencies).toBlocking().single().body();
    }

    /**
     * Reactivate - single.
     * Reactivate a previously deactivated list item.
     *
     * @param listItemId The list item id.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @param allowMissingDependencies Allow reactivating list items that refer to list items or contents that don't exist in the system.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemDetail> reactivateAsync(String listItemId, String timeout, String patterns, String allowMissingDependencies, final ServiceCallback<ListItemDetail> serviceCallback) {
        return ServiceFuture.fromResponse(reactivateWithServiceResponseAsync(listItemId, timeout, patterns, allowMissingDependencies), serviceCallback);
    }

    /**
     * Reactivate - single.
     * Reactivate a previously deactivated list item.
     *
     * @param listItemId The list item id.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @param allowMissingDependencies Allow reactivating list items that refer to list items or contents that don't exist in the system.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ListItemDetail> reactivateAsync(String listItemId, String timeout, String patterns, String allowMissingDependencies) {
        return reactivateWithServiceResponseAsync(listItemId, timeout, patterns, allowMissingDependencies).map(new Func1<ServiceResponse<ListItemDetail>, ListItemDetail>() {
            // @Override
            public ListItemDetail call(ServiceResponse<ListItemDetail> response) {
                return response.body();
            }
        });
    }

    /**
     * Reactivate - single.
     * Reactivate a previously deactivated list item.
     *
     * @param listItemId The list item id.
     * @param timeout Maximum time to wait for the business process completed state.
     * @param patterns List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @param allowMissingDependencies Allow reactivating list items that refer to list items or contents that don't exist in the system.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemDetail object
     */
    public Observable<ServiceResponse<ListItemDetail>> reactivateWithServiceResponseAsync(String listItemId, String timeout, String patterns, String allowMissingDependencies) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        return service.reactivate(listItemId, timeout, patterns, allowMissingDependencies)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemDetail>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemDetail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemDetail> clientResponse = reactivateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ListItemDetail> reactivateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListItemDetail, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemDetail>() { }.getType())
                .build(response);
    }

    /**
     * Reactivate - many.
     * Reactivate previously deactivated list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param reactivateRequest The list items reactivate request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BusinessProcess object if successful.
     */
    public BusinessProcess reactivateMany(ListItemReactivateRequest reactivateRequest) {
        return reactivateManyWithServiceResponseAsync(reactivateRequest).toBlocking().single().body();
    }

    /**
     * Reactivate - many.
     * Reactivate previously deactivated list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param reactivateRequest The list items reactivate request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BusinessProcess> reactivateManyAsync(ListItemReactivateRequest reactivateRequest, final ServiceCallback<BusinessProcess> serviceCallback) {
        return ServiceFuture.fromResponse(reactivateManyWithServiceResponseAsync(reactivateRequest), serviceCallback);
    }

    /**
     * Reactivate - many.
     * Reactivate previously deactivated list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param reactivateRequest The list items reactivate request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<BusinessProcess> reactivateManyAsync(ListItemReactivateRequest reactivateRequest) {
        return reactivateManyWithServiceResponseAsync(reactivateRequest).map(new Func1<ServiceResponse<BusinessProcess>, BusinessProcess>() {
            // @Override
            public BusinessProcess call(ServiceResponse<BusinessProcess> response) {
                return response.body();
            }
        });
    }

    /**
     * Reactivate - many.
     * Reactivate previously deactivated list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param reactivateRequest The list items reactivate request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<ServiceResponse<BusinessProcess>> reactivateManyWithServiceResponseAsync(ListItemReactivateRequest reactivateRequest) {
        if (reactivateRequest == null) {
            throw new IllegalArgumentException("Parameter reactivateRequest is required and cannot be null.");
        }
        Validator.validate(reactivateRequest);
        return service.reactivateMany(reactivateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BusinessProcess>>>() {
                // @Override
                public Observable<ServiceResponse<BusinessProcess>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BusinessProcess> clientResponse = reactivateManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BusinessProcess> reactivateManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BusinessProcess, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .build(response);
    }

    /**
     * Batch update fields - by ids.
     * Update fields of multiple list items. A list of listItemIds must be provided to limit the update to specific list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BusinessProcess object if successful.
     */
    public BusinessProcess batchUpdateFieldsByIds(ListItemFieldsUpdateRequest updateRequest) {
        return batchUpdateFieldsByIdsWithServiceResponseAsync(updateRequest).toBlocking().single().body();
    }

    /**
     * Batch update fields - by ids.
     * Update fields of multiple list items. A list of listItemIds must be provided to limit the update to specific list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param updateRequest The metadata update request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BusinessProcess> batchUpdateFieldsByIdsAsync(ListItemFieldsUpdateRequest updateRequest, final ServiceCallback<BusinessProcess> serviceCallback) {
        return ServiceFuture.fromResponse(batchUpdateFieldsByIdsWithServiceResponseAsync(updateRequest), serviceCallback);
    }

    /**
     * Batch update fields - by ids.
     * Update fields of multiple list items. A list of listItemIds must be provided to limit the update to specific list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<BusinessProcess> batchUpdateFieldsByIdsAsync(ListItemFieldsUpdateRequest updateRequest) {
        return batchUpdateFieldsByIdsWithServiceResponseAsync(updateRequest).map(new Func1<ServiceResponse<BusinessProcess>, BusinessProcess>() {
            // @Override
            public BusinessProcess call(ServiceResponse<BusinessProcess> response) {
                return response.body();
            }
        });
    }

    /**
     * Batch update fields - by ids.
     * Update fields of multiple list items. A list of listItemIds must be provided to limit the update to specific list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<ServiceResponse<BusinessProcess>> batchUpdateFieldsByIdsWithServiceResponseAsync(ListItemFieldsUpdateRequest updateRequest) {
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.batchUpdateFieldsByIds(updateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BusinessProcess>>>() {
                // @Override
                public Observable<ServiceResponse<BusinessProcess>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BusinessProcess> clientResponse = batchUpdateFieldsByIdsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BusinessProcess> batchUpdateFieldsByIdsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BusinessProcess, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .build(response);
    }

    /**
     * Batch update fields - by filter.
     * Update fields of multiple list items. A filter must be provided to limit the update to specific list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BusinessProcess object if successful.
     */
    public BusinessProcess batchUpdateFieldsByFilter(ListItemFieldsFilterUpdateRequest updateRequest) {
        return batchUpdateFieldsByFilterWithServiceResponseAsync(updateRequest).toBlocking().single().body();
    }

    /**
     * Batch update fields - by filter.
     * Update fields of multiple list items. A filter must be provided to limit the update to specific list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param updateRequest The metadata update request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BusinessProcess> batchUpdateFieldsByFilterAsync(ListItemFieldsFilterUpdateRequest updateRequest, final ServiceCallback<BusinessProcess> serviceCallback) {
        return ServiceFuture.fromResponse(batchUpdateFieldsByFilterWithServiceResponseAsync(updateRequest), serviceCallback);
    }

    /**
     * Batch update fields - by filter.
     * Update fields of multiple list items. A filter must be provided to limit the update to specific list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<BusinessProcess> batchUpdateFieldsByFilterAsync(ListItemFieldsFilterUpdateRequest updateRequest) {
        return batchUpdateFieldsByFilterWithServiceResponseAsync(updateRequest).map(new Func1<ServiceResponse<BusinessProcess>, BusinessProcess>() {
            // @Override
            public BusinessProcess call(ServiceResponse<BusinessProcess> response) {
                return response.body();
            }
        });
    }

    /**
     * Batch update fields - by filter.
     * Update fields of multiple list items. A filter must be provided to limit the update to specific list items.
     The operation is executed asynchronous and is not awaited. Call [WaitForCompletion](#operation/BusinessProcess_WaitForCompletion) to wait for the process to finish.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BusinessProcess object
     */
    public Observable<ServiceResponse<BusinessProcess>> batchUpdateFieldsByFilterWithServiceResponseAsync(ListItemFieldsFilterUpdateRequest updateRequest) {
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.batchUpdateFieldsByFilter(updateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BusinessProcess>>>() {
                // @Override
                public Observable<ServiceResponse<BusinessProcess>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BusinessProcess> clientResponse = batchUpdateFieldsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BusinessProcess> batchUpdateFieldsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BusinessProcess, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .build(response);
    }

    /**
     * Gets the references to a list item.
     *
     * @param listItemId The ID of the list item.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListItemReferences object if successful.
     */
    public ListItemReferences getReferencesToListItem(String listItemId) {
        return getReferencesToListItemWithServiceResponseAsync(listItemId).toBlocking().single().body();
    }

    /**
     * Gets the references to a list item.
     *
     * @param listItemId The ID of the list item.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListItemReferences> getReferencesToListItemAsync(String listItemId, final ServiceCallback<ListItemReferences> serviceCallback) {
        return ServiceFuture.fromResponse(getReferencesToListItemWithServiceResponseAsync(listItemId), serviceCallback);
    }

    /**
     * Gets the references to a list item.
     *
     * @param listItemId The ID of the list item.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemReferences object
     */
    public Observable<ListItemReferences> getReferencesToListItemAsync(String listItemId) {
        return getReferencesToListItemWithServiceResponseAsync(listItemId).map(new Func1<ServiceResponse<ListItemReferences>, ListItemReferences>() {
            // @Override
            public ListItemReferences call(ServiceResponse<ListItemReferences> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the references to a list item.
     *
     * @param listItemId The ID of the list item.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListItemReferences object
     */
    public Observable<ServiceResponse<ListItemReferences>> getReferencesToListItemWithServiceResponseAsync(String listItemId) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        return service.getReferencesToListItem(listItemId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListItemReferences>>>() {
                // @Override
                public Observable<ServiceResponse<ListItemReferences>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListItemReferences> clientResponse = getReferencesToListItemDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ListItemReferences> getReferencesToListItemDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListItemReferences, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemReferences>() { }.getType())
                .build(response);
    }

    /**
     * Gets the references to the specified list items.
     *
     * @param ids The IDs of the list items.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ListItemReferences&gt; object if successful.
     */
    public List<ListItemReferences> getReferencesToListItems(String ids) {
        return getReferencesToListItemsWithServiceResponseAsync(ids).toBlocking().single().body();
    }

    /**
     * Gets the references to the specified list items.
     *
     * @param ids The IDs of the list items.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ListItemReferences>> getReferencesToListItemsAsync(String ids, final ServiceCallback<List<ListItemReferences>> serviceCallback) {
        return ServiceFuture.fromResponse(getReferencesToListItemsWithServiceResponseAsync(ids), serviceCallback);
    }

    /**
     * Gets the references to the specified list items.
     *
     * @param ids The IDs of the list items.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ListItemReferences&gt; object
     */
    public Observable<List<ListItemReferences>> getReferencesToListItemsAsync(String ids) {
        return getReferencesToListItemsWithServiceResponseAsync(ids).map(new Func1<ServiceResponse<List<ListItemReferences>>, List<ListItemReferences>>() {
            // @Override
            public List<ListItemReferences> call(ServiceResponse<List<ListItemReferences>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the references to the specified list items.
     *
     * @param ids The IDs of the list items.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ListItemReferences&gt; object
     */
    public Observable<ServiceResponse<List<ListItemReferences>>> getReferencesToListItemsWithServiceResponseAsync(String ids) {
        if (ids == null) {
            throw new IllegalArgumentException("Parameter ids is required and cannot be null.");
        }
        return service.getReferencesToListItems(ids)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ListItemReferences>>>>() {
                // @Override
                public Observable<ServiceResponse<List<ListItemReferences>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ListItemReferences>> clientResponse = getReferencesToListItemsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ListItemReferences>> getReferencesToListItemsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ListItemReferences>, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ListItemReferences>>() { }.getType())
                .build(response);
    }

}
