/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package foobar.implementation;

import retrofit2.Retrofit;
import foobar.Transfers;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import foobar.models.Blacklist;
import foobar.models.CreateTransferRequest;
import foobar.models.FileTransfer2ContentCreateRequest;
import foobar.models.FileTransferDeleteRequest;
import foobar.models.FileTransferDetail;
import foobar.models.FileTransferPartial2ContentCreateRequest;
import foobar.models.FileTransferSearchRequest;
import foobar.models.FileTransferSearchResult;
import foobar.models.PictureparkException;
import foobar.models.Transfer;
import foobar.models.TransferDetail;
import foobar.models.TransferSearchRequest;
import foobar.models.TransferSearchResult;
import java.io.InputStream;
import java.io.IOException;

import okhttp3.MediaType;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Multipart;
import retrofit2.http.Part;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Transfers.
 */
public class TransfersImpl implements Transfers {
    /** The Retrofit service to perform REST calls. */
    private TransfersService service;
    /** The service client containing this operation class. */
    private WebAPISwaggerspecificationImpl client;

    /**
     * Initializes an instance of Transfers.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public TransfersImpl(Retrofit retrofit, WebAPISwaggerspecificationImpl client) {
        this.service = retrofit.create(TransfersService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Transfers to be
     * used by Retrofit to perform actually REST calls.
     */
    interface TransfersService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers deleteFiles" })
        @POST("V1/Transfers/Files/Delete")
        Observable<Response<ResponseBody>> deleteFiles(@Body FileTransferDeleteRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers getBlacklist" })
        @GET("V1/Transfers/Files/Blacklist")
        Observable<Response<ResponseBody>> getBlacklist();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers cancelTransfer" })
        @GET("V1/Transfers/{TransferId}/Cancel")
        Observable<Response<ResponseBody>> cancelTransfer(@Path("TransferId") String transferId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers create" })
        @POST("V1/Transfers")
        Observable<Response<ResponseBody>> create(@Body CreateTransferRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers delete" })
        @HTTP(path = "V1/Transfers/{TransferId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("TransferId") String transferId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers get" })
        @GET("V1/Transfers/{TransferId}")
        Observable<Response<ResponseBody>> get(@Path("TransferId") String transferId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers getFile" })
        @GET("V1/Transfers/Files/{FileTransferId}")
        Observable<Response<ResponseBody>> getFile(@Path("FileTransferId") String fileTransferId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers importTransfer" })
        @POST("V1/Transfers/{TransferId}/Import")
        Observable<Response<ResponseBody>> importTransfer(@Path("TransferId") String transferId, @Body FileTransfer2ContentCreateRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers partialImport" })
        @POST("V1/Transfers/{TransferId}/PartialImport")
        Observable<Response<ResponseBody>> partialImport(@Path("TransferId") String transferId, @Body FileTransferPartial2ContentCreateRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers search" })
        @POST("V1/Transfers/Search")
        Observable<Response<ResponseBody>> search(@Body TransferSearchRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: foobar.Transfers searchFiles" })
        @POST("V1/Transfers/Files/Search")
        Observable<Response<ResponseBody>> searchFiles(@Body FileTransferSearchRequest request);

        @Multipart
        @POST("V1/Transfers/{TransferId}/Files/{Identifier}/Upload")
        Observable<Response<ResponseBody>> uploadFile(@Path("TransferId") String transferId, @Path("Identifier") String identifier, @Part("formFile") RequestBody formFile, @Query("relativePath") String relativePath, @Query("chunkNumber") Long chunkNumber, @Query("currentChunkSize") Long currentChunkSize, @Query("totalSize") Long totalSize, @Query("totalChunks") Long totalChunks);

    }

    /**
     * Delete Files.
     *
     * @param request The filetransfer delete request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PictureparkException object if successful.
     */
    public PictureparkException deleteFiles(FileTransferDeleteRequest request) {
        return deleteFilesWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Delete Files.
     *
     * @param request The filetransfer delete request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PictureparkException> deleteFilesAsync(FileTransferDeleteRequest request, final ServiceCallback<PictureparkException> serviceCallback) {
        return ServiceFuture.fromResponse(deleteFilesWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Delete Files.
     *
     * @param request The filetransfer delete request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<PictureparkException> deleteFilesAsync(FileTransferDeleteRequest request) {
        return deleteFilesWithServiceResponseAsync(request).map(new Func1<ServiceResponse<PictureparkException>, PictureparkException>() {
            
            public PictureparkException call(ServiceResponse<PictureparkException> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete Files.
     *
     * @param request The filetransfer delete request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<ServiceResponse<PictureparkException>> deleteFilesWithServiceResponseAsync(FileTransferDeleteRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.deleteFiles(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PictureparkException>>>() {
                
                public Observable<ServiceResponse<PictureparkException>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PictureparkException> clientResponse = deleteFilesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PictureparkException> deleteFilesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PictureparkException, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Get Blacklist.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getBlacklist() {
        return getBlacklistWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get Blacklist.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getBlacklistAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getBlacklistWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get Blacklist.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getBlacklistAsync() {
        return getBlacklistWithServiceResponseAsync().map(new Func1<ServiceResponse<Object>, Object>() {
            
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Blacklist.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getBlacklistWithServiceResponseAsync() {
        return service.getBlacklist()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getBlacklistDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getBlacklistDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Blacklist>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Cancels an active transfer. Valid states: TODO.
     *
     * @param transferId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PictureparkException object if successful.
     */
    public PictureparkException cancelTransfer(String transferId) {
        return cancelTransferWithServiceResponseAsync(transferId).toBlocking().single().body();
    }

    /**
     * Cancels an active transfer. Valid states: TODO.
     *
     * @param transferId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PictureparkException> cancelTransferAsync(String transferId, final ServiceCallback<PictureparkException> serviceCallback) {
        return ServiceFuture.fromResponse(cancelTransferWithServiceResponseAsync(transferId), serviceCallback);
    }

    /**
     * Cancels an active transfer. Valid states: TODO.
     *
     * @param transferId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<PictureparkException> cancelTransferAsync(String transferId) {
        return cancelTransferWithServiceResponseAsync(transferId).map(new Func1<ServiceResponse<PictureparkException>, PictureparkException>() {
            
            public PictureparkException call(ServiceResponse<PictureparkException> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancels an active transfer. Valid states: TODO.
     *
     * @param transferId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<ServiceResponse<PictureparkException>> cancelTransferWithServiceResponseAsync(String transferId) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        return service.cancelTransfer(transferId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PictureparkException>>>() {
                
                public Observable<ServiceResponse<PictureparkException>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PictureparkException> clientResponse = cancelTransferDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PictureparkException> cancelTransferDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PictureparkException, RestException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Create Transfer.
     *
     * @param request The create transfer request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object create(CreateTransferRequest request) {
        return createWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Create Transfer.
     *
     * @param request The create transfer request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAsync(CreateTransferRequest request, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Create Transfer.
     *
     * @param request The create transfer request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAsync(CreateTransferRequest request) {
        return createWithServiceResponseAsync(request).map(new Func1<ServiceResponse<Object>, Object>() {
            
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create Transfer.
     *
     * @param request The create transfer request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createWithServiceResponseAsync(CreateTransferRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.create(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Transfer>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PictureparkException object if successful.
     */
    public PictureparkException delete(String transferId) {
        return deleteWithServiceResponseAsync(transferId).toBlocking().single().body();
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PictureparkException> deleteAsync(String transferId, final ServiceCallback<PictureparkException> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(transferId), serviceCallback);
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<PictureparkException> deleteAsync(String transferId) {
        return deleteWithServiceResponseAsync(transferId).map(new Func1<ServiceResponse<PictureparkException>, PictureparkException>() {
            
            public PictureparkException call(ServiceResponse<PictureparkException> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<ServiceResponse<PictureparkException>> deleteWithServiceResponseAsync(String transferId) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        return service.delete(transferId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PictureparkException>>>() {
                
                public Observable<ServiceResponse<PictureparkException>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PictureparkException> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PictureparkException> deleteDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PictureparkException, RestException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Get Transferdetail.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object get(String transferId) {
        return getWithServiceResponseAsync(transferId).toBlocking().single().body();
    }

    /**
     * Get Transferdetail.
     *
     * @param transferId The tranfer id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAsync(String transferId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(transferId), serviceCallback);
    }

    /**
     * Get Transferdetail.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAsync(String transferId) {
        return getWithServiceResponseAsync(transferId).map(new Func1<ServiceResponse<Object>, Object>() {
            
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Transferdetail.
     *
     * @param transferId The tranfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getWithServiceResponseAsync(String transferId) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        return service.get(transferId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TransferDetail>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Get File.
     *
     * @param fileTransferId The filetransfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getFile(String fileTransferId) {
        return getFileWithServiceResponseAsync(fileTransferId).toBlocking().single().body();
    }

    /**
     * Get File.
     *
     * @param fileTransferId The filetransfer id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getFileAsync(String fileTransferId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getFileWithServiceResponseAsync(fileTransferId), serviceCallback);
    }

    /**
     * Get File.
     *
     * @param fileTransferId The filetransfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getFileAsync(String fileTransferId) {
        return getFileWithServiceResponseAsync(fileTransferId).map(new Func1<ServiceResponse<Object>, Object>() {
            
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get File.
     *
     * @param fileTransferId The filetransfer id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getFileWithServiceResponseAsync(String fileTransferId) {
        if (fileTransferId == null) {
            throw new IllegalArgumentException("Parameter fileTransferId is required and cannot be null.");
        }
        return service.getFile(fileTransferId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getFileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getFileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FileTransferDetail>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @param request The filetransfer to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object importTransfer(String transferId, FileTransfer2ContentCreateRequest request) {
        return importTransferWithServiceResponseAsync(transferId, request).toBlocking().single().body();
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @param request The filetransfer to content create request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> importTransferAsync(String transferId, FileTransfer2ContentCreateRequest request, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(importTransferWithServiceResponseAsync(transferId, request), serviceCallback);
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @param request The filetransfer to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> importTransferAsync(String transferId, FileTransfer2ContentCreateRequest request) {
        return importTransferWithServiceResponseAsync(transferId, request).map(new Func1<ServiceResponse<Object>, Object>() {
            
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete Transfer.
     *
     * @param transferId The tranfer id
     * @param request The filetransfer to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> importTransferWithServiceResponseAsync(String transferId, FileTransfer2ContentCreateRequest request) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.importTransfer(transferId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = importTransferDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> importTransferDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Transfer>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Create a partial import.
     *
     * @param transferId The transfer id
     * @param request The filetransfer partial to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object partialImport(String transferId, FileTransferPartial2ContentCreateRequest request) {
        return partialImportWithServiceResponseAsync(transferId, request).toBlocking().single().body();
    }

    /**
     * Create a partial import.
     *
     * @param transferId The transfer id
     * @param request The filetransfer partial to content create request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> partialImportAsync(String transferId, FileTransferPartial2ContentCreateRequest request, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(partialImportWithServiceResponseAsync(transferId, request), serviceCallback);
    }

    /**
     * Create a partial import.
     *
     * @param transferId The transfer id
     * @param request The filetransfer partial to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> partialImportAsync(String transferId, FileTransferPartial2ContentCreateRequest request) {
        return partialImportWithServiceResponseAsync(transferId, request).map(new Func1<ServiceResponse<Object>, Object>() {
            
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a partial import.
     *
     * @param transferId The transfer id
     * @param request The filetransfer partial to content create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> partialImportWithServiceResponseAsync(String transferId, FileTransferPartial2ContentCreateRequest request) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.partialImport(transferId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = partialImportDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> partialImportDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Transfer>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Search.
     *
     * @param request The transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object search(TransferSearchRequest request) {
        return searchWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Search.
     *
     * @param request The transfer search request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> searchAsync(TransferSearchRequest request, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(searchWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Search.
     *
     * @param request The transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> searchAsync(TransferSearchRequest request) {
        return searchWithServiceResponseAsync(request).map(new Func1<ServiceResponse<Object>, Object>() {
            
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Search.
     *
     * @param request The transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> searchWithServiceResponseAsync(TransferSearchRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.search(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = searchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> searchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TransferSearchResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     * Search for files.
     *
     * @param request The file transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object searchFiles(FileTransferSearchRequest request) {
        return searchFilesWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Search for files.
     *
     * @param request The file transfer search request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> searchFilesAsync(FileTransferSearchRequest request, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(searchFilesWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Search for files.
     *
     * @param request The file transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> searchFilesAsync(FileTransferSearchRequest request) {
        return searchFilesWithServiceResponseAsync(request).map(new Func1<ServiceResponse<Object>, Object>() {
            
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Search for files.
     *
     * @param request The file transfer search request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> searchFilesWithServiceResponseAsync(FileTransferSearchRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.searchFiles(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = searchFilesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> searchFilesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FileTransferSearchResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

    /**
     *
     * @param transferId the String value
     * @param identifier the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PictureparkException object if successful.
     */
    public PictureparkException uploadFile(String transferId, String identifier) {
        return uploadFileWithServiceResponseAsync(transferId, identifier).toBlocking().single().body();
    }

    /**
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PictureparkException> uploadFileAsync(String transferId, String identifier, final ServiceCallback<PictureparkException> serviceCallback) {
        return ServiceFuture.fromResponse(uploadFileWithServiceResponseAsync(transferId, identifier), serviceCallback);
    }

    /**
     *
     * @param transferId the String value
     * @param identifier the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<PictureparkException> uploadFileAsync(String transferId, String identifier) {
        return uploadFileWithServiceResponseAsync(transferId, identifier).map(new Func1<ServiceResponse<PictureparkException>, PictureparkException>() {
            
            public PictureparkException call(ServiceResponse<PictureparkException> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param transferId the String value
     * @param identifier the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<ServiceResponse<PictureparkException>> uploadFileWithServiceResponseAsync(String transferId, String identifier) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        if (identifier == null) {
            throw new IllegalArgumentException("Parameter identifier is required and cannot be null.");
        }
        final byte[] formFile = new byte[0];
        final String relativePath = null;
        final Long chunkNumber = null;
        final Long currentChunkSize = null;
        final Long totalSize = null;
        final Long totalChunks = null;
        RequestBody formFileConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (formFile != null) {
            formFileConverted = RequestBody.create(MediaType.parse("multipart/form-data"), formFile);
        }
        return service.uploadFile(transferId, identifier, formFileConverted, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PictureparkException>>>() {
                public Observable<ServiceResponse<PictureparkException>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PictureparkException> clientResponse = uploadFileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param formFile Gets or sets the form file.
     * @param relativePath Relative path of the uploading file
     * @param chunkNumber Current chunk number. starts with 1
     * @param currentChunkSize Size in bytes of the current chunk
     * @param totalSize Total size in bytes of the uploading file
     * @param totalChunks Total chunks of the uploading file
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PictureparkException object if successful.
     */
    public PictureparkException uploadFile(String transferId, String identifier, byte[] formFile, String relativePath, Long chunkNumber, Long currentChunkSize, Long totalSize, Long totalChunks) {
        return uploadFileWithServiceResponseAsync(transferId, identifier, formFile, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks).toBlocking().single().body();
    }

    /**
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param formFile Gets or sets the form file.
     * @param relativePath Relative path of the uploading file
     * @param chunkNumber Current chunk number. starts with 1
     * @param currentChunkSize Size in bytes of the current chunk
     * @param totalSize Total size in bytes of the uploading file
     * @param totalChunks Total chunks of the uploading file
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PictureparkException> uploadFileAsync(String transferId, String identifier, byte[] formFile, String relativePath, Long chunkNumber, Long currentChunkSize, Long totalSize, Long totalChunks, final ServiceCallback<PictureparkException> serviceCallback) {
        return ServiceFuture.fromResponse(uploadFileWithServiceResponseAsync(transferId, identifier, formFile, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks), serviceCallback);
    }

    /**
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param formFile Gets or sets the form file.
     * @param relativePath Relative path of the uploading file
     * @param chunkNumber Current chunk number. starts with 1
     * @param currentChunkSize Size in bytes of the current chunk
     * @param totalSize Total size in bytes of the uploading file
     * @param totalChunks Total chunks of the uploading file
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<PictureparkException> uploadFileAsync(String transferId, String identifier, byte[] formFile, String relativePath, Long chunkNumber, Long currentChunkSize, Long totalSize, Long totalChunks) {
        return uploadFileWithServiceResponseAsync(transferId, identifier, formFile, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks).map(new Func1<ServiceResponse<PictureparkException>, PictureparkException>() {
            
            public PictureparkException call(ServiceResponse<PictureparkException> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param transferId the String value
     * @param identifier the String value
     * @param formFile Gets or sets the form file.
     * @param relativePath Relative path of the uploading file
     * @param chunkNumber Current chunk number. starts with 1
     * @param currentChunkSize Size in bytes of the current chunk
     * @param totalSize Total size in bytes of the uploading file
     * @param totalChunks Total chunks of the uploading file
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<ServiceResponse<PictureparkException>> uploadFileWithServiceResponseAsync(String transferId, String identifier, byte[] formFile, String relativePath, Long chunkNumber, Long currentChunkSize, Long totalSize, Long totalChunks) {
        if (transferId == null) {
            throw new IllegalArgumentException("Parameter transferId is required and cannot be null.");
        }
        if (identifier == null) {
            throw new IllegalArgumentException("Parameter identifier is required and cannot be null.");
        }
        RequestBody formFileConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (formFile != null) {
            formFileConverted = RequestBody.create(MediaType.parse("multipart/form-data"), formFile);
        }
        return service.uploadFile(transferId, identifier, formFileConverted, relativePath, chunkNumber, currentChunkSize, totalSize, totalChunks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PictureparkException>>>() {
					
                public Observable<ServiceResponse<PictureparkException>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PictureparkException> clientResponse = uploadFileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PictureparkException> uploadFileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PictureparkException, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .build(response);
    }

}
