/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package picturepark.implementation;

import retrofit2.Retrofit;
import picturepark.Schemas;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import picturepark.models.BusinessProcess;
import picturepark.models.ExistsResponse;
import picturepark.models.PictureparkException;
import picturepark.models.SchemaCreateRequest;
import picturepark.models.SchemaDetail;
import picturepark.models.SchemaSearchRequest;
import picturepark.models.SchemaSearchResult;
import picturepark.models.SchemaUpdateRequest;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Schemas.
 */
public class SchemasImpl implements Schemas {
    /** The Retrofit service to perform REST calls. */
    private SchemasService service;
    /** The service client containing this operation class. */
    private WebAPISwaggerspecificationImpl client;

    /**
     * Initializes an instance of Schemas.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public SchemasImpl(Retrofit retrofit, WebAPISwaggerspecificationImpl client) {
        this.service = retrofit.create(SchemasService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Schemas to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SchemasService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Schemas getMany" })
        @GET("V1/Schemas")
        Observable<Response<ResponseBody>> getMany(@Query("ids") String ids);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Schemas create" })
        @POST("V1/Schemas")
        Observable<Response<ResponseBody>> create(@Body SchemaCreateRequest schema);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Schemas get" })
        @GET("V1/Schemas/{SchemaId}")
        Observable<Response<ResponseBody>> get(@Path("SchemaId") String schemaId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Schemas update" })
        @PUT("V1/Schemas/{SchemaId}")
        Observable<Response<ResponseBody>> update(@Path("SchemaId") String schemaId, @Body SchemaUpdateRequest schema);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Schemas delete" })
        @HTTP(path = "V1/Schemas/{SchemaId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("SchemaId") String schemaId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Schemas exists" })
        @GET("V1/Schemas/{SchemaId}/Exists")
        Observable<Response<ResponseBody>> exists(@Path("SchemaId") String schemaId, @Query("fieldId") String fieldId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Schemas search" })
        @POST("V1/Schemas/Search")
        Observable<Response<ResponseBody>> search(@Body SchemaSearchRequest schemaSearchRequest);

    }

    /**
     * Get Many.
     * Gets the schema detail informations by given schema ids.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getMany() {
        return getManyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get Many.
     * Gets the schema detail informations by given schema ids.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getManyAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getManyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get Many.
     * Gets the schema detail informations by given schema ids.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getManyAsync() {
        return getManyWithServiceResponseAsync().map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Many.
     * Gets the schema detail informations by given schema ids.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getManyWithServiceResponseAsync() {
        final List<String> ids = null;
        String idsConverted = this.client.serializerAdapter().serializeList(ids, CollectionFormat.MULTI);
        return service.getMany(idsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get Many.
     * Gets the schema detail informations by given schema ids.
     *
     * @param ids Comma separated list of schema ids
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getMany(List<String> ids) {
        return getManyWithServiceResponseAsync(ids).toBlocking().single().body();
    }

    /**
     * Get Many.
     * Gets the schema detail informations by given schema ids.
     *
     * @param ids Comma separated list of schema ids
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getManyAsync(List<String> ids, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getManyWithServiceResponseAsync(ids), serviceCallback);
    }

    /**
     * Get Many.
     * Gets the schema detail informations by given schema ids.
     *
     * @param ids Comma separated list of schema ids
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getManyAsync(List<String> ids) {
        return getManyWithServiceResponseAsync(ids).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Many.
     * Gets the schema detail informations by given schema ids.
     *
     * @param ids Comma separated list of schema ids
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getManyWithServiceResponseAsync(List<String> ids) {
        Validator.validate(ids);
        String idsConverted = this.client.serializerAdapter().serializeList(ids, CollectionFormat.MULTI);
        return service.getMany(idsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getManyDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<SchemaDetail>>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Create Single.
     * The creation of a single schema is executed asynchronous. To keep track of the creation progress a business process is returned.
     *
     * @param schema The schema create request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object create(SchemaCreateRequest schema) {
        return createWithServiceResponseAsync(schema).toBlocking().single().body();
    }

    /**
     * Create Single.
     * The creation of a single schema is executed asynchronous. To keep track of the creation progress a business process is returned.
     *
     * @param schema The schema create request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAsync(SchemaCreateRequest schema, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(schema), serviceCallback);
    }

    /**
     * Create Single.
     * The creation of a single schema is executed asynchronous. To keep track of the creation progress a business process is returned.
     *
     * @param schema The schema create request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAsync(SchemaCreateRequest schema) {
        return createWithServiceResponseAsync(schema).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create Single.
     * The creation of a single schema is executed asynchronous. To keep track of the creation progress a business process is returned.
     *
     * @param schema The schema create request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createWithServiceResponseAsync(SchemaCreateRequest schema) {
        if (schema == null) {
            throw new IllegalArgumentException("Parameter schema is required and cannot be null.");
        }
        Validator.validate(schema);
        return service.create(schema)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get Single.
     * Gets the schema detail information by the schema id.
     *
     * @param schemaId The schema id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object get(String schemaId) {
        return getWithServiceResponseAsync(schemaId).toBlocking().single().body();
    }

    /**
     * Get Single.
     * Gets the schema detail information by the schema id.
     *
     * @param schemaId The schema id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAsync(String schemaId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(schemaId), serviceCallback);
    }

    /**
     * Get Single.
     * Gets the schema detail information by the schema id.
     *
     * @param schemaId The schema id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAsync(String schemaId) {
        return getWithServiceResponseAsync(schemaId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Single.
     * Gets the schema detail information by the schema id.
     *
     * @param schemaId The schema id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getWithServiceResponseAsync(String schemaId) {
        if (schemaId == null) {
            throw new IllegalArgumentException("Parameter schemaId is required and cannot be null.");
        }
        return service.get(schemaId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SchemaDetail>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update Single.
     * The update of a single schema is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param schemaId The schema id.
     * @param schema The schema update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object update(String schemaId, SchemaUpdateRequest schema) {
        return updateWithServiceResponseAsync(schemaId, schema).toBlocking().single().body();
    }

    /**
     * Update Single.
     * The update of a single schema is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param schemaId The schema id.
     * @param schema The schema update request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAsync(String schemaId, SchemaUpdateRequest schema, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(schemaId, schema), serviceCallback);
    }

    /**
     * Update Single.
     * The update of a single schema is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param schemaId The schema id.
     * @param schema The schema update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAsync(String schemaId, SchemaUpdateRequest schema) {
        return updateWithServiceResponseAsync(schemaId, schema).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single.
     * The update of a single schema is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param schemaId The schema id.
     * @param schema The schema update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateWithServiceResponseAsync(String schemaId, SchemaUpdateRequest schema) {
        if (schemaId == null) {
            throw new IllegalArgumentException("Parameter schemaId is required and cannot be null.");
        }
        if (schema == null) {
            throw new IllegalArgumentException("Parameter schema is required and cannot be null.");
        }
        Validator.validate(schema);
        return service.update(schemaId, schema)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Delete Single.
     * The deletion of a single schema is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @param schemaId The schema id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object delete(String schemaId) {
        return deleteWithServiceResponseAsync(schemaId).toBlocking().single().body();
    }

    /**
     * Delete Single.
     * The deletion of a single schema is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @param schemaId The schema id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteAsync(String schemaId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(schemaId), serviceCallback);
    }

    /**
     * Delete Single.
     * The deletion of a single schema is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @param schemaId The schema id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteAsync(String schemaId) {
        return deleteWithServiceResponseAsync(schemaId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete Single.
     * The deletion of a single schema is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @param schemaId The schema id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteWithServiceResponseAsync(String schemaId) {
        if (schemaId == null) {
            throw new IllegalArgumentException("Parameter schemaId is required and cannot be null.");
        }
        return service.delete(schemaId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Exists.
     * Checks if the schema or optionally the schema's field already exists.
     *
     * @param schemaId The schema id.
     * @param fieldId The optional field id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object exists(String schemaId, String fieldId) {
        return existsWithServiceResponseAsync(schemaId, fieldId).toBlocking().single().body();
    }

    /**
     * Exists.
     * Checks if the schema or optionally the schema's field already exists.
     *
     * @param schemaId The schema id.
     * @param fieldId The optional field id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> existsAsync(String schemaId, String fieldId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(existsWithServiceResponseAsync(schemaId, fieldId), serviceCallback);
    }

    /**
     * Exists.
     * Checks if the schema or optionally the schema's field already exists.
     *
     * @param schemaId The schema id.
     * @param fieldId The optional field id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> existsAsync(String schemaId, String fieldId) {
        return existsWithServiceResponseAsync(schemaId, fieldId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Exists.
     * Checks if the schema or optionally the schema's field already exists.
     *
     * @param schemaId The schema id.
     * @param fieldId The optional field id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> existsWithServiceResponseAsync(String schemaId, String fieldId) {
        if (schemaId == null) {
            throw new IllegalArgumentException("Parameter schemaId is required and cannot be null.");
        }
        if (fieldId == null) {
            throw new IllegalArgumentException("Parameter fieldId is required and cannot be null.");
        }
        return service.exists(schemaId, fieldId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = existsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> existsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ExistsResponse>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Search.
     * Searches schemas as specified in the search request.
     *
     * @param schemaSearchRequest The schema search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object search(SchemaSearchRequest schemaSearchRequest) {
        return searchWithServiceResponseAsync(schemaSearchRequest).toBlocking().single().body();
    }

    /**
     * Search.
     * Searches schemas as specified in the search request.
     *
     * @param schemaSearchRequest The schema search request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> searchAsync(SchemaSearchRequest schemaSearchRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(searchWithServiceResponseAsync(schemaSearchRequest), serviceCallback);
    }

    /**
     * Search.
     * Searches schemas as specified in the search request.
     *
     * @param schemaSearchRequest The schema search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> searchAsync(SchemaSearchRequest schemaSearchRequest) {
        return searchWithServiceResponseAsync(schemaSearchRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Search.
     * Searches schemas as specified in the search request.
     *
     * @param schemaSearchRequest The schema search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> searchWithServiceResponseAsync(SchemaSearchRequest schemaSearchRequest) {
        if (schemaSearchRequest == null) {
            throw new IllegalArgumentException("Parameter schemaSearchRequest is required and cannot be null.");
        }
        Validator.validate(schemaSearchRequest);
        return service.search(schemaSearchRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = searchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> searchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SchemaSearchResult>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

}
