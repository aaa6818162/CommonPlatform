/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package picturepark.implementation;

import retrofit2.Retrofit;
import picturepark.Contents;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import picturepark.models.BusinessProcess;
import picturepark.models.ContentAggregationRequest;
import picturepark.models.ContentBatchDownloadItem;
import picturepark.models.ContentBatchDownloadRequest;
import picturepark.models.ContentDeactivationRequest;
import picturepark.models.ContentDetail;
import picturepark.models.ContentFileUpdateRequest;
import picturepark.models.ContentNotFoundException;
import picturepark.models.ContentOwnershipTransferRequest;
import picturepark.models.ContentReactivationRequest;
import picturepark.models.ContentSearchRequest;
import picturepark.models.ContentSearchResult;
import picturepark.models.ContentsMetadataUpdateRequest;
import picturepark.models.ContentsOwnershipTransferRequest;
import picturepark.models.CreateContentRequest;
import picturepark.models.FilterContentsMetadataUpdateRequest;
import picturepark.models.ObjectAggregationResult;
import picturepark.models.PictureparkException;
import picturepark.models.UpdateContentMetadataRequest;
import picturepark.models.UpdateContentPermissionsRequest;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Contents.
 */
public class ContentsImpl implements Contents {
    /** The Retrofit service to perform REST calls. */
    private ContentsService service;
    /** The service client containing this operation class. */
    private WebAPISwaggerspecificationImpl client;

    /**
     * Initializes an instance of Contents.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ContentsImpl(Retrofit retrofit, WebAPISwaggerspecificationImpl client) {
        this.service = retrofit.create(ContentsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Contents to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ContentsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents updateTransferOwnership" })
        @PUT("V1/Contents/{ContentId}/Ownership/Transfer")
        Observable<Response<ResponseBody>> updateTransferOwnership(@Path("ContentId") String contentId, @Body ContentOwnershipTransferRequest updateRequest, @Query("timeout") Integer timeout);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents getMany" })
        @GET("V1/Contents/Many")
        Observable<Response<ResponseBody>> getMany(@Query("ids") String ids, @Query("resolve") boolean resolve, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents transferOwnershipMany" })
        @POST("V1/Contents/Many/Ownership/Transfer")
        Observable<Response<ResponseBody>> transferOwnershipMany(@Body ContentsOwnershipTransferRequest contentsOwnershipTransferRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents aggregate" })
        @POST("V1/Contents/Aggregate")
        Observable<Response<ResponseBody>> aggregate(@Body ContentAggregationRequest contentAggregationRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents aggregateByChannel" })
        @POST("V1/Contents/{ChannelId}/Aggregate")
        Observable<Response<ResponseBody>> aggregateByChannel(@Path("ChannelId") String channelId, @Body ContentAggregationRequest contentAggregationRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents createDownloadLink" })
        @POST("V1/Contents/CreateBatchContentDownload")
        Observable<Response<ResponseBody>> createDownloadLink(@Body ContentBatchDownloadRequest request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents createContent" })
        @POST("V1/Contents")
        Observable<Response<ResponseBody>> createContent(@Body CreateContentRequest createRequest, @Query("resolve") boolean resolve, @Query("timeout") Integer timeout, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents download" })
        @GET("V1/Contents/Downloads/{ContentId}/{OutputFormatId}")
        Observable<Response<ResponseBody>> download(@Path("ContentId") String contentId, @Path("OutputFormatId") String outputFormatId, @Header("Range") String range);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents downloadThumbnail" })
        @GET("V1/Contents/Thumbnails/{ContentId}/{Size}")
        Observable<Response<ResponseBody>> downloadThumbnail(@Path("ContentId") String contentId, @Path("Size") String size);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents downloadResized" })
        @GET("V1/Contents/Downloads/{ContentId}/{OutputFormatId}/{Width}/{Height}")
        Observable<Response<ResponseBody>> downloadResized(@Path("ContentId") String contentId, @Path("OutputFormatId") String outputFormatId, @Path("Width") int width, @Path("Height") int height);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents get" })
        @GET("V1/Contents/{ContentId}")
        Observable<Response<ResponseBody>> get(@Path("ContentId") String contentId, @Query("resolve") boolean resolve, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents updateMetadata" })
        @PUT("V1/Contents/{ContentId}")
        Observable<Response<ResponseBody>> updateMetadata(@Path("ContentId") String contentId, @Body UpdateContentMetadataRequest updateRequest, @Query("resolve") boolean resolve, @Query("timeout") Integer timeout, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents updatePermissions" })
        @PUT("V1/Contents/{ContentId}/Permissions")
        Observable<Response<ResponseBody>> updatePermissions(@Path("ContentId") String contentId, @Body UpdateContentPermissionsRequest updateRequest, @Query("resolve") boolean resolve, @Query("timeout") Integer timeout, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents search" })
        @POST("V1/Contents/Search")
        Observable<Response<ResponseBody>> search(@Body ContentSearchRequest contentSearchRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents searchByChannel" })
        @POST("V1/Contents/{ChannelId}/Search")
        Observable<Response<ResponseBody>> searchByChannel(@Path("ChannelId") String channelId, @Body ContentSearchRequest contentSearchRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents deactivate" })
        @PUT("V1/Contents/{ContentId}/Deactivate")
        Observable<Response<ResponseBody>> deactivate(@Path("ContentId") String contentId, @Query("timeout") int timeout);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents updateFile" })
        @PUT("V1/Contents/{ContentId}/File")
        Observable<Response<ResponseBody>> updateFile(@Path("ContentId") String contentId, @Body ContentFileUpdateRequest updateRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents reactivate" })
        @PUT("V1/Contents/{ContentId}/Reactivate")
        Observable<Response<ResponseBody>> reactivate(@Path("ContentId") String contentId, @Query("resolve") boolean resolve, @Query("timeout") Integer timeout, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents deactivateMany" })
        @POST("V1/Contents/Many/Deactivate")
        Observable<Response<ResponseBody>> deactivateMany(@Body ContentDeactivationRequest deactivationRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents reactivateMany" })
        @POST("V1/Contents/Many/Reactivate")
        Observable<Response<ResponseBody>> reactivateMany(@Body ContentReactivationRequest reactivationRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents updateMetadataMany" })
        @PUT("V1/Contents/Many/Metadata")
        Observable<Response<ResponseBody>> updateMetadataMany(@Body ContentsMetadataUpdateRequest updateRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents updateMetadataByFilter" })
        @PUT("V1/Contents/Many/Metadata/Filter")
        Observable<Response<ResponseBody>> updateMetadataByFilter(@Body FilterContentsMetadataUpdateRequest updateRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.Contents updatePermissionsMany" })
        @PUT("V1/Contents/Many/Permissions")
        Observable<Response<ResponseBody>> updatePermissionsMany(@Body List<UpdateContentPermissionsRequest> updateRequest);

    }

    /**
     * Update Single - OwnershipTransfer.
     * The update of content transfer is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content ownership transfer request update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateTransferOwnership(String contentId, ContentOwnershipTransferRequest updateRequest) {
        return updateTransferOwnershipWithServiceResponseAsync(contentId, updateRequest).toBlocking().single().body();
    }

    /**
     * Update Single - OwnershipTransfer.
     * The update of content transfer is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content ownership transfer request update request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateTransferOwnershipAsync(String contentId, ContentOwnershipTransferRequest updateRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateTransferOwnershipWithServiceResponseAsync(contentId, updateRequest), serviceCallback);
    }

    /**
     * Update Single - OwnershipTransfer.
     * The update of content transfer is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content ownership transfer request update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateTransferOwnershipAsync(String contentId, ContentOwnershipTransferRequest updateRequest) {
        return updateTransferOwnershipWithServiceResponseAsync(contentId, updateRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single - OwnershipTransfer.
     * The update of content transfer is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content ownership transfer request update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateTransferOwnershipWithServiceResponseAsync(String contentId, ContentOwnershipTransferRequest updateRequest) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        final Integer timeout = null;
        return service.updateTransferOwnership(contentId, updateRequest, timeout)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateTransferOwnershipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update Single - OwnershipTransfer.
     * The update of content transfer is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content ownership transfer request update request.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateTransferOwnership(String contentId, ContentOwnershipTransferRequest updateRequest, Integer timeout) {
        return updateTransferOwnershipWithServiceResponseAsync(contentId, updateRequest, timeout).toBlocking().single().body();
    }

    /**
     * Update Single - OwnershipTransfer.
     * The update of content transfer is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content ownership transfer request update request.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateTransferOwnershipAsync(String contentId, ContentOwnershipTransferRequest updateRequest, Integer timeout, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateTransferOwnershipWithServiceResponseAsync(contentId, updateRequest, timeout), serviceCallback);
    }

    /**
     * Update Single - OwnershipTransfer.
     * The update of content transfer is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content ownership transfer request update request.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateTransferOwnershipAsync(String contentId, ContentOwnershipTransferRequest updateRequest, Integer timeout) {
        return updateTransferOwnershipWithServiceResponseAsync(contentId, updateRequest, timeout).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single - OwnershipTransfer.
     * The update of content transfer is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content ownership transfer request update request.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateTransferOwnershipWithServiceResponseAsync(String contentId, ContentOwnershipTransferRequest updateRequest, Integer timeout) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.updateTransferOwnership(contentId, updateRequest, timeout)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateTransferOwnershipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateTransferOwnershipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContentDetail>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get Many.
     * Gets multiple content documents by ids.
     *
     * @param ids Comma-separated list of contentIds
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getMany(List<String> ids, boolean resolve) {
        return getManyWithServiceResponseAsync(ids, resolve).toBlocking().single().body();
    }

    /**
     * Get Many.
     * Gets multiple content documents by ids.
     *
     * @param ids Comma-separated list of contentIds
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getManyAsync(List<String> ids, boolean resolve, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getManyWithServiceResponseAsync(ids, resolve), serviceCallback);
    }

    /**
     * Get Many.
     * Gets multiple content documents by ids.
     *
     * @param ids Comma-separated list of contentIds
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getManyAsync(List<String> ids, boolean resolve) {
        return getManyWithServiceResponseAsync(ids, resolve).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Many.
     * Gets multiple content documents by ids.
     *
     * @param ids Comma-separated list of contentIds
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getManyWithServiceResponseAsync(List<String> ids, boolean resolve) {
        if (ids == null) {
            throw new IllegalArgumentException("Parameter ids is required and cannot be null.");
        }
        Validator.validate(ids);
        final List<String> patterns = null;
        String idsConverted = this.client.serializerAdapter().serializeList(ids, CollectionFormat.MULTI);String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.getMany(idsConverted, resolve, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get Many.
     * Gets multiple content documents by ids.
     *
     * @param ids Comma-separated list of contentIds
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getMany(List<String> ids, boolean resolve, List<String> patterns) {
        return getManyWithServiceResponseAsync(ids, resolve, patterns).toBlocking().single().body();
    }

    /**
     * Get Many.
     * Gets multiple content documents by ids.
     *
     * @param ids Comma-separated list of contentIds
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getManyAsync(List<String> ids, boolean resolve, List<String> patterns, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getManyWithServiceResponseAsync(ids, resolve, patterns), serviceCallback);
    }

    /**
     * Get Many.
     * Gets multiple content documents by ids.
     *
     * @param ids Comma-separated list of contentIds
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getManyAsync(List<String> ids, boolean resolve, List<String> patterns) {
        return getManyWithServiceResponseAsync(ids, resolve, patterns).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Many.
     * Gets multiple content documents by ids.
     *
     * @param ids Comma-separated list of contentIds
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getManyWithServiceResponseAsync(List<String> ids, boolean resolve, List<String> patterns) {
        if (ids == null) {
            throw new IllegalArgumentException("Parameter ids is required and cannot be null.");
        }
        Validator.validate(ids);
        Validator.validate(patterns);
        String idsConverted = this.client.serializerAdapter().serializeList(ids, CollectionFormat.MULTI);String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.getMany(idsConverted, resolve, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ContentDetail>>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Process many ownership trasnfer request.
     *
     * @param contentsOwnershipTransferRequest The content ownership transfer request request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object transferOwnershipMany(ContentsOwnershipTransferRequest contentsOwnershipTransferRequest) {
        return transferOwnershipManyWithServiceResponseAsync(contentsOwnershipTransferRequest).toBlocking().single().body();
    }

    /**
     * Process many ownership trasnfer request.
     *
     * @param contentsOwnershipTransferRequest The content ownership transfer request request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> transferOwnershipManyAsync(ContentsOwnershipTransferRequest contentsOwnershipTransferRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(transferOwnershipManyWithServiceResponseAsync(contentsOwnershipTransferRequest), serviceCallback);
    }

    /**
     * Process many ownership trasnfer request.
     *
     * @param contentsOwnershipTransferRequest The content ownership transfer request request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> transferOwnershipManyAsync(ContentsOwnershipTransferRequest contentsOwnershipTransferRequest) {
        return transferOwnershipManyWithServiceResponseAsync(contentsOwnershipTransferRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Process many ownership trasnfer request.
     *
     * @param contentsOwnershipTransferRequest The content ownership transfer request request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> transferOwnershipManyWithServiceResponseAsync(ContentsOwnershipTransferRequest contentsOwnershipTransferRequest) {
        if (contentsOwnershipTransferRequest == null) {
            throw new IllegalArgumentException("Parameter contentsOwnershipTransferRequest is required and cannot be null.");
        }
        Validator.validate(contentsOwnershipTransferRequest);
        return service.transferOwnershipMany(contentsOwnershipTransferRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = transferOwnershipManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> transferOwnershipManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Aggregate.
     * Aggregates content as specified in the aggregation request.
     *
     * @param contentAggregationRequest The aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object aggregate(ContentAggregationRequest contentAggregationRequest) {
        return aggregateWithServiceResponseAsync(contentAggregationRequest).toBlocking().single().body();
    }

    /**
     * Aggregate.
     * Aggregates content as specified in the aggregation request.
     *
     * @param contentAggregationRequest The aggregation request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> aggregateAsync(ContentAggregationRequest contentAggregationRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(aggregateWithServiceResponseAsync(contentAggregationRequest), serviceCallback);
    }

    /**
     * Aggregate.
     * Aggregates content as specified in the aggregation request.
     *
     * @param contentAggregationRequest The aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> aggregateAsync(ContentAggregationRequest contentAggregationRequest) {
        return aggregateWithServiceResponseAsync(contentAggregationRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Aggregate.
     * Aggregates content as specified in the aggregation request.
     *
     * @param contentAggregationRequest The aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> aggregateWithServiceResponseAsync(ContentAggregationRequest contentAggregationRequest) {
        if (contentAggregationRequest == null) {
            throw new IllegalArgumentException("Parameter contentAggregationRequest is required and cannot be null.");
        }
        Validator.validate(contentAggregationRequest);
        return service.aggregate(contentAggregationRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = aggregateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> aggregateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ObjectAggregationResult>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Aggregate by Channel.
     * Aggregates content as specified in the aggregation request and limits the aggregation results to the specified channel.
     *
     * @param channelId The channel id
     * @param contentAggregationRequest The content aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object aggregateByChannel(String channelId, ContentAggregationRequest contentAggregationRequest) {
        return aggregateByChannelWithServiceResponseAsync(channelId, contentAggregationRequest).toBlocking().single().body();
    }

    /**
     * Aggregate by Channel.
     * Aggregates content as specified in the aggregation request and limits the aggregation results to the specified channel.
     *
     * @param channelId The channel id
     * @param contentAggregationRequest The content aggregation request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> aggregateByChannelAsync(String channelId, ContentAggregationRequest contentAggregationRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(aggregateByChannelWithServiceResponseAsync(channelId, contentAggregationRequest), serviceCallback);
    }

    /**
     * Aggregate by Channel.
     * Aggregates content as specified in the aggregation request and limits the aggregation results to the specified channel.
     *
     * @param channelId The channel id
     * @param contentAggregationRequest The content aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> aggregateByChannelAsync(String channelId, ContentAggregationRequest contentAggregationRequest) {
        return aggregateByChannelWithServiceResponseAsync(channelId, contentAggregationRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Aggregate by Channel.
     * Aggregates content as specified in the aggregation request and limits the aggregation results to the specified channel.
     *
     * @param channelId The channel id
     * @param contentAggregationRequest The content aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> aggregateByChannelWithServiceResponseAsync(String channelId, ContentAggregationRequest contentAggregationRequest) {
        if (channelId == null) {
            throw new IllegalArgumentException("Parameter channelId is required and cannot be null.");
        }
        if (contentAggregationRequest == null) {
            throw new IllegalArgumentException("Parameter contentAggregationRequest is required and cannot be null.");
        }
        Validator.validate(contentAggregationRequest);
        return service.aggregateByChannel(channelId, contentAggregationRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = aggregateByChannelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> aggregateByChannelDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ObjectAggregationResult>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a content batch download.
     *
     * @param request The content batch download request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createDownloadLink(ContentBatchDownloadRequest request) {
        return createDownloadLinkWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Creates a content batch download.
     *
     * @param request The content batch download request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createDownloadLinkAsync(ContentBatchDownloadRequest request, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createDownloadLinkWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Creates a content batch download.
     *
     * @param request The content batch download request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createDownloadLinkAsync(ContentBatchDownloadRequest request) {
        return createDownloadLinkWithServiceResponseAsync(request).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a content batch download.
     *
     * @param request The content batch download request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createDownloadLinkWithServiceResponseAsync(ContentBatchDownloadRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.createDownloadLink(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createDownloadLinkDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createDownloadLinkDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContentBatchDownloadItem>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Create Single.
     * The creation of content is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param createRequest The content create request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createContent(CreateContentRequest createRequest, boolean resolve) {
        return createContentWithServiceResponseAsync(createRequest, resolve).toBlocking().single().body();
    }

    /**
     * Create Single.
     * The creation of content is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param createRequest The content create request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createContentAsync(CreateContentRequest createRequest, boolean resolve, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createContentWithServiceResponseAsync(createRequest, resolve), serviceCallback);
    }

    /**
     * Create Single.
     * The creation of content is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param createRequest The content create request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createContentAsync(CreateContentRequest createRequest, boolean resolve) {
        return createContentWithServiceResponseAsync(createRequest, resolve).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create Single.
     * The creation of content is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param createRequest The content create request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createContentWithServiceResponseAsync(CreateContentRequest createRequest, boolean resolve) {
        if (createRequest == null) {
            throw new IllegalArgumentException("Parameter createRequest is required and cannot be null.");
        }
        Validator.validate(createRequest);
        final Integer timeout = null;
        final List<String> patterns = null;
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.createContent(createRequest, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create Single.
     * The creation of content is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param createRequest The content create request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createContent(CreateContentRequest createRequest, boolean resolve, Integer timeout, List<String> patterns) {
        return createContentWithServiceResponseAsync(createRequest, resolve, timeout, patterns).toBlocking().single().body();
    }

    /**
     * Create Single.
     * The creation of content is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param createRequest The content create request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createContentAsync(CreateContentRequest createRequest, boolean resolve, Integer timeout, List<String> patterns, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createContentWithServiceResponseAsync(createRequest, resolve, timeout, patterns), serviceCallback);
    }

    /**
     * Create Single.
     * The creation of content is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param createRequest The content create request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createContentAsync(CreateContentRequest createRequest, boolean resolve, Integer timeout, List<String> patterns) {
        return createContentWithServiceResponseAsync(createRequest, resolve, timeout, patterns).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create Single.
     * The creation of content is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param createRequest The content create request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createContentWithServiceResponseAsync(CreateContentRequest createRequest, boolean resolve, Integer timeout, List<String> patterns) {
        if (createRequest == null) {
            throw new IllegalArgumentException("Parameter createRequest is required and cannot be null.");
        }
        Validator.validate(createRequest);
        Validator.validate(patterns);
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.createContent(createRequest, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createContentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContentDetail>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Downloads content in a specific outputformat.
     *
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object download(String contentId, String outputFormatId) {
        return downloadWithServiceResponseAsync(contentId, outputFormatId).toBlocking().single().body();
    }

    /**
     * Downloads content in a specific outputformat.
     *
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> downloadAsync(String contentId, String outputFormatId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(downloadWithServiceResponseAsync(contentId, outputFormatId), serviceCallback);
    }

    /**
     * Downloads content in a specific outputformat.
     *
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> downloadAsync(String contentId, String outputFormatId) {
        return downloadWithServiceResponseAsync(contentId, outputFormatId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Downloads content in a specific outputformat.
     *
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> downloadWithServiceResponseAsync(String contentId, String outputFormatId) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (outputFormatId == null) {
            throw new IllegalArgumentException("Parameter outputFormatId is required and cannot be null.");
        }
        final String range = null;
        return service.download(contentId, outputFormatId, range)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = downloadDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Downloads content in a specific outputformat.
     *
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @param range the range
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object download(String contentId, String outputFormatId, String range) {
        return downloadWithServiceResponseAsync(contentId, outputFormatId, range).toBlocking().single().body();
    }

    /**
     * Downloads content in a specific outputformat.
     *
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @param range the range
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> downloadAsync(String contentId, String outputFormatId, String range, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(downloadWithServiceResponseAsync(contentId, outputFormatId, range), serviceCallback);
    }

    /**
     * Downloads content in a specific outputformat.
     *
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @param range the range
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> downloadAsync(String contentId, String outputFormatId, String range) {
        return downloadWithServiceResponseAsync(contentId, outputFormatId, range).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Downloads content in a specific outputformat.
     *
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @param range the range
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> downloadWithServiceResponseAsync(String contentId, String outputFormatId, String range) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (outputFormatId == null) {
            throw new IllegalArgumentException("Parameter outputFormatId is required and cannot be null.");
        }
        return service.download(contentId, outputFormatId, range)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = downloadDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> downloadDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(206, new TypeToken<InputStream>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get Thumbnail.
     * Provides a lightweight endpoint to get content thumbnails.
     *
     * @param contentId The Content id
     * @param size Thumbnail size. Either small, medium or large
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object downloadThumbnail(String contentId, String size) {
        return downloadThumbnailWithServiceResponseAsync(contentId, size).toBlocking().single().body();
    }

    /**
     * Get Thumbnail.
     * Provides a lightweight endpoint to get content thumbnails.
     *
     * @param contentId The Content id
     * @param size Thumbnail size. Either small, medium or large
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> downloadThumbnailAsync(String contentId, String size, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(downloadThumbnailWithServiceResponseAsync(contentId, size), serviceCallback);
    }

    /**
     * Get Thumbnail.
     * Provides a lightweight endpoint to get content thumbnails.
     *
     * @param contentId The Content id
     * @param size Thumbnail size. Either small, medium or large
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> downloadThumbnailAsync(String contentId, String size) {
        return downloadThumbnailWithServiceResponseAsync(contentId, size).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Thumbnail.
     * Provides a lightweight endpoint to get content thumbnails.
     *
     * @param contentId The Content id
     * @param size Thumbnail size. Either small, medium or large
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> downloadThumbnailWithServiceResponseAsync(String contentId, String size) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (size == null) {
            throw new IllegalArgumentException("Parameter size is required and cannot be null.");
        }
        return service.downloadThumbnail(contentId, size)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = downloadThumbnailDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> downloadThumbnailDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Download resized content.
     * Provides a endpoint to get reseized content.
     *
     * @param contentId The Content id
     * @param outputFormatId The output format id
     * @param width The content width
     * @param height The content height
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object downloadResized(String contentId, String outputFormatId, int width, int height) {
        return downloadResizedWithServiceResponseAsync(contentId, outputFormatId, width, height).toBlocking().single().body();
    }

    /**
     * Download resized content.
     * Provides a endpoint to get reseized content.
     *
     * @param contentId The Content id
     * @param outputFormatId The output format id
     * @param width The content width
     * @param height The content height
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> downloadResizedAsync(String contentId, String outputFormatId, int width, int height, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(downloadResizedWithServiceResponseAsync(contentId, outputFormatId, width, height), serviceCallback);
    }

    /**
     * Download resized content.
     * Provides a endpoint to get reseized content.
     *
     * @param contentId The Content id
     * @param outputFormatId The output format id
     * @param width The content width
     * @param height The content height
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> downloadResizedAsync(String contentId, String outputFormatId, int width, int height) {
        return downloadResizedWithServiceResponseAsync(contentId, outputFormatId, width, height).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Download resized content.
     * Provides a endpoint to get reseized content.
     *
     * @param contentId The Content id
     * @param outputFormatId The output format id
     * @param width The content width
     * @param height The content height
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> downloadResizedWithServiceResponseAsync(String contentId, String outputFormatId, int width, int height) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (outputFormatId == null) {
            throw new IllegalArgumentException("Parameter outputFormatId is required and cannot be null.");
        }
        return service.downloadResized(contentId, outputFormatId, width, height)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = downloadResizedDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> downloadResizedDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get Single.
     * Gets a content document by id.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object get(String contentId, boolean resolve) {
        return getWithServiceResponseAsync(contentId, resolve).toBlocking().single().body();
    }

    /**
     * Get Single.
     * Gets a content document by id.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAsync(String contentId, boolean resolve, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(contentId, resolve), serviceCallback);
    }

    /**
     * Get Single.
     * Gets a content document by id.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAsync(String contentId, boolean resolve) {
        return getWithServiceResponseAsync(contentId, resolve).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Single.
     * Gets a content document by id.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getWithServiceResponseAsync(String contentId, boolean resolve) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        final List<String> patterns = null;
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.get(contentId, resolve, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get Single.
     * Gets a content document by id.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object get(String contentId, boolean resolve, List<String> patterns) {
        return getWithServiceResponseAsync(contentId, resolve, patterns).toBlocking().single().body();
    }

    /**
     * Get Single.
     * Gets a content document by id.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAsync(String contentId, boolean resolve, List<String> patterns, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(contentId, resolve, patterns), serviceCallback);
    }

    /**
     * Get Single.
     * Gets a content document by id.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAsync(String contentId, boolean resolve, List<String> patterns) {
        return getWithServiceResponseAsync(contentId, resolve, patterns).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Single.
     * Gets a content document by id.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getWithServiceResponseAsync(String contentId, boolean resolve, List<String> patterns) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        Validator.validate(patterns);
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.get(contentId, resolve, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(404, new TypeToken<ContentNotFoundException>() { }.getType())
                .register(200, new TypeToken<ContentDetail>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update Single - Metadata.
     * The update of content metadata is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The metadata update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateMetadata(String contentId, UpdateContentMetadataRequest updateRequest, boolean resolve) {
        return updateMetadataWithServiceResponseAsync(contentId, updateRequest, resolve).toBlocking().single().body();
    }

    /**
     * Update Single - Metadata.
     * The update of content metadata is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The metadata update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateMetadataAsync(String contentId, UpdateContentMetadataRequest updateRequest, boolean resolve, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateMetadataWithServiceResponseAsync(contentId, updateRequest, resolve), serviceCallback);
    }

    /**
     * Update Single - Metadata.
     * The update of content metadata is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The metadata update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateMetadataAsync(String contentId, UpdateContentMetadataRequest updateRequest, boolean resolve) {
        return updateMetadataWithServiceResponseAsync(contentId, updateRequest, resolve).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single - Metadata.
     * The update of content metadata is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The metadata update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateMetadataWithServiceResponseAsync(String contentId, UpdateContentMetadataRequest updateRequest, boolean resolve) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        final Integer timeout = null;
        final List<String> patterns = null;
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.updateMetadata(contentId, updateRequest, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update Single - Metadata.
     * The update of content metadata is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The metadata update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateMetadata(String contentId, UpdateContentMetadataRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns) {
        return updateMetadataWithServiceResponseAsync(contentId, updateRequest, resolve, timeout, patterns).toBlocking().single().body();
    }

    /**
     * Update Single - Metadata.
     * The update of content metadata is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The metadata update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateMetadataAsync(String contentId, UpdateContentMetadataRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateMetadataWithServiceResponseAsync(contentId, updateRequest, resolve, timeout, patterns), serviceCallback);
    }

    /**
     * Update Single - Metadata.
     * The update of content metadata is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The metadata update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateMetadataAsync(String contentId, UpdateContentMetadataRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns) {
        return updateMetadataWithServiceResponseAsync(contentId, updateRequest, resolve, timeout, patterns).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single - Metadata.
     * The update of content metadata is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The metadata update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateMetadataWithServiceResponseAsync(String contentId, UpdateContentMetadataRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        Validator.validate(patterns);
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.updateMetadata(contentId, updateRequest, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContentDetail>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update Single - Permissions.
     * The update of content permissions is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content permission update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updatePermissions(String contentId, UpdateContentPermissionsRequest updateRequest, boolean resolve) {
        return updatePermissionsWithServiceResponseAsync(contentId, updateRequest, resolve).toBlocking().single().body();
    }

    /**
     * Update Single - Permissions.
     * The update of content permissions is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content permission update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updatePermissionsAsync(String contentId, UpdateContentPermissionsRequest updateRequest, boolean resolve, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updatePermissionsWithServiceResponseAsync(contentId, updateRequest, resolve), serviceCallback);
    }

    /**
     * Update Single - Permissions.
     * The update of content permissions is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content permission update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updatePermissionsAsync(String contentId, UpdateContentPermissionsRequest updateRequest, boolean resolve) {
        return updatePermissionsWithServiceResponseAsync(contentId, updateRequest, resolve).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single - Permissions.
     * The update of content permissions is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content permission update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updatePermissionsWithServiceResponseAsync(String contentId, UpdateContentPermissionsRequest updateRequest, boolean resolve) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        final Integer timeout = null;
        final List<String> patterns = null;
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.updatePermissions(contentId, updateRequest, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updatePermissionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update Single - Permissions.
     * The update of content permissions is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content permission update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updatePermissions(String contentId, UpdateContentPermissionsRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns) {
        return updatePermissionsWithServiceResponseAsync(contentId, updateRequest, resolve, timeout, patterns).toBlocking().single().body();
    }

    /**
     * Update Single - Permissions.
     * The update of content permissions is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content permission update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updatePermissionsAsync(String contentId, UpdateContentPermissionsRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updatePermissionsWithServiceResponseAsync(contentId, updateRequest, resolve, timeout, patterns), serviceCallback);
    }

    /**
     * Update Single - Permissions.
     * The update of content permissions is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content permission update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updatePermissionsAsync(String contentId, UpdateContentPermissionsRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns) {
        return updatePermissionsWithServiceResponseAsync(contentId, updateRequest, resolve, timeout, patterns).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single - Permissions.
     * The update of content permissions is executed asynchronous. However, for the specified timeout completion of the update process is awaited.
     If the update process is not completed by reaching the specified timeout, the update process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param updateRequest The content permission update request.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updatePermissionsWithServiceResponseAsync(String contentId, UpdateContentPermissionsRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        Validator.validate(patterns);
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.updatePermissions(contentId, updateRequest, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updatePermissionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updatePermissionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContentDetail>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Search.
     * Searches contents as specified in the search request.
     *
     * @param contentSearchRequest The content search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object search(ContentSearchRequest contentSearchRequest) {
        return searchWithServiceResponseAsync(contentSearchRequest).toBlocking().single().body();
    }

    /**
     * Search.
     * Searches contents as specified in the search request.
     *
     * @param contentSearchRequest The content search request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> searchAsync(ContentSearchRequest contentSearchRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(searchWithServiceResponseAsync(contentSearchRequest), serviceCallback);
    }

    /**
     * Search.
     * Searches contents as specified in the search request.
     *
     * @param contentSearchRequest The content search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> searchAsync(ContentSearchRequest contentSearchRequest) {
        return searchWithServiceResponseAsync(contentSearchRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Search.
     * Searches contents as specified in the search request.
     *
     * @param contentSearchRequest The content search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> searchWithServiceResponseAsync(ContentSearchRequest contentSearchRequest) {
        if (contentSearchRequest == null) {
            throw new IllegalArgumentException("Parameter contentSearchRequest is required and cannot be null.");
        }
        Validator.validate(contentSearchRequest);
        return service.search(contentSearchRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = searchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> searchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContentSearchResult>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Search By Channel.
     * Searches contents as specified in the search request and limits the search results to the specified channel.
     *
     * @param channelId The channel id.
     * @param contentSearchRequest The content search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object searchByChannel(String channelId, ContentSearchRequest contentSearchRequest) {
        return searchByChannelWithServiceResponseAsync(channelId, contentSearchRequest).toBlocking().single().body();
    }

    /**
     * Search By Channel.
     * Searches contents as specified in the search request and limits the search results to the specified channel.
     *
     * @param channelId The channel id.
     * @param contentSearchRequest The content search request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> searchByChannelAsync(String channelId, ContentSearchRequest contentSearchRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(searchByChannelWithServiceResponseAsync(channelId, contentSearchRequest), serviceCallback);
    }

    /**
     * Search By Channel.
     * Searches contents as specified in the search request and limits the search results to the specified channel.
     *
     * @param channelId The channel id.
     * @param contentSearchRequest The content search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> searchByChannelAsync(String channelId, ContentSearchRequest contentSearchRequest) {
        return searchByChannelWithServiceResponseAsync(channelId, contentSearchRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Search By Channel.
     * Searches contents as specified in the search request and limits the search results to the specified channel.
     *
     * @param channelId The channel id.
     * @param contentSearchRequest The content search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> searchByChannelWithServiceResponseAsync(String channelId, ContentSearchRequest contentSearchRequest) {
        if (channelId == null) {
            throw new IllegalArgumentException("Parameter channelId is required and cannot be null.");
        }
        if (contentSearchRequest == null) {
            throw new IllegalArgumentException("Parameter contentSearchRequest is required and cannot be null.");
        }
        Validator.validate(contentSearchRequest);
        return service.searchByChannel(channelId, contentSearchRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = searchByChannelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> searchByChannelDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContentSearchResult>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deactivates a content.
     *
     * @param contentId the id of the content to deactivate
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PictureparkException object if successful.
     */
    public PictureparkException deactivate(String contentId, int timeout) {
        return deactivateWithServiceResponseAsync(contentId, timeout).toBlocking().single().body();
    }

    /**
     * Deactivates a content.
     *
     * @param contentId the id of the content to deactivate
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PictureparkException> deactivateAsync(String contentId, int timeout, final ServiceCallback<PictureparkException> serviceCallback) {
        return ServiceFuture.fromResponse(deactivateWithServiceResponseAsync(contentId, timeout), serviceCallback);
    }

    /**
     * Deactivates a content.
     *
     * @param contentId the id of the content to deactivate
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<PictureparkException> deactivateAsync(String contentId, int timeout) {
        return deactivateWithServiceResponseAsync(contentId, timeout).map(new Func1<ServiceResponse<PictureparkException>, PictureparkException>() {
            @Override
            public PictureparkException call(ServiceResponse<PictureparkException> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivates a content.
     *
     * @param contentId the id of the content to deactivate
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<ServiceResponse<PictureparkException>> deactivateWithServiceResponseAsync(String contentId, int timeout) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        return service.deactivate(contentId, timeout)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PictureparkException>>>() {
                @Override
                public Observable<ServiceResponse<PictureparkException>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PictureparkException> clientResponse = deactivateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PictureparkException> deactivateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PictureparkException, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update Single - File.
     * Update binary file of existing content. The file must already be uploaded before calling this endpoint.
     *
     * @param contentId The id of the content to replace
     * @param updateRequest Update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateFile(String contentId, ContentFileUpdateRequest updateRequest) {
        return updateFileWithServiceResponseAsync(contentId, updateRequest).toBlocking().single().body();
    }

    /**
     * Update Single - File.
     * Update binary file of existing content. The file must already be uploaded before calling this endpoint.
     *
     * @param contentId The id of the content to replace
     * @param updateRequest Update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateFileAsync(String contentId, ContentFileUpdateRequest updateRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateFileWithServiceResponseAsync(contentId, updateRequest), serviceCallback);
    }

    /**
     * Update Single - File.
     * Update binary file of existing content. The file must already be uploaded before calling this endpoint.
     *
     * @param contentId The id of the content to replace
     * @param updateRequest Update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateFileAsync(String contentId, ContentFileUpdateRequest updateRequest) {
        return updateFileWithServiceResponseAsync(contentId, updateRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single - File.
     * Update binary file of existing content. The file must already be uploaded before calling this endpoint.
     *
     * @param contentId The id of the content to replace
     * @param updateRequest Update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateFileWithServiceResponseAsync(String contentId, ContentFileUpdateRequest updateRequest) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.updateFile(contentId, updateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateFileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateFileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Reactivate - Content.
     * The reactivation of content is executed asynchronous. However, for the specified timeout completion of the reactivation process is awaited.
     If the reactivation process is not completed by reaching the specified timeout, the reactivation process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object reactivate(String contentId, boolean resolve) {
        return reactivateWithServiceResponseAsync(contentId, resolve).toBlocking().single().body();
    }

    /**
     * Reactivate - Content.
     * The reactivation of content is executed asynchronous. However, for the specified timeout completion of the reactivation process is awaited.
     If the reactivation process is not completed by reaching the specified timeout, the reactivation process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> reactivateAsync(String contentId, boolean resolve, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(reactivateWithServiceResponseAsync(contentId, resolve), serviceCallback);
    }

    /**
     * Reactivate - Content.
     * The reactivation of content is executed asynchronous. However, for the specified timeout completion of the reactivation process is awaited.
     If the reactivation process is not completed by reaching the specified timeout, the reactivation process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> reactivateAsync(String contentId, boolean resolve) {
        return reactivateWithServiceResponseAsync(contentId, resolve).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Reactivate - Content.
     * The reactivation of content is executed asynchronous. However, for the specified timeout completion of the reactivation process is awaited.
     If the reactivation process is not completed by reaching the specified timeout, the reactivation process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> reactivateWithServiceResponseAsync(String contentId, boolean resolve) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        final Integer timeout = null;
        final List<String> patterns = null;
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.reactivate(contentId, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = reactivateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Reactivate - Content.
     * The reactivation of content is executed asynchronous. However, for the specified timeout completion of the reactivation process is awaited.
     If the reactivation process is not completed by reaching the specified timeout, the reactivation process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object reactivate(String contentId, boolean resolve, Integer timeout, List<String> patterns) {
        return reactivateWithServiceResponseAsync(contentId, resolve, timeout, patterns).toBlocking().single().body();
    }

    /**
     * Reactivate - Content.
     * The reactivation of content is executed asynchronous. However, for the specified timeout completion of the reactivation process is awaited.
     If the reactivation process is not completed by reaching the specified timeout, the reactivation process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> reactivateAsync(String contentId, boolean resolve, Integer timeout, List<String> patterns, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(reactivateWithServiceResponseAsync(contentId, resolve, timeout, patterns), serviceCallback);
    }

    /**
     * Reactivate - Content.
     * The reactivation of content is executed asynchronous. However, for the specified timeout completion of the reactivation process is awaited.
     If the reactivation process is not completed by reaching the specified timeout, the reactivation process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> reactivateAsync(String contentId, boolean resolve, Integer timeout, List<String> patterns) {
        return reactivateWithServiceResponseAsync(contentId, resolve, timeout, patterns).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Reactivate - Content.
     * The reactivation of content is executed asynchronous. However, for the specified timeout completion of the reactivation process is awaited.
     If the reactivation process is not completed by reaching the specified timeout, the reactivation process continues, but null is returned.
     *
     * @param contentId The content id.
     * @param resolve Resolves the data of referenced list items into the contents's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> reactivateWithServiceResponseAsync(String contentId, boolean resolve, Integer timeout, List<String> patterns) {
        if (contentId == null) {
            throw new IllegalArgumentException("Parameter contentId is required and cannot be null.");
        }
        Validator.validate(patterns);
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.reactivate(contentId, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = reactivateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> reactivateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ContentDetail>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Dactivate Many - Content.
     *
     * @param deactivationRequest The deactivation request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deactivateMany(ContentDeactivationRequest deactivationRequest) {
        return deactivateManyWithServiceResponseAsync(deactivationRequest).toBlocking().single().body();
    }

    /**
     * Dactivate Many - Content.
     *
     * @param deactivationRequest The deactivation request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deactivateManyAsync(ContentDeactivationRequest deactivationRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deactivateManyWithServiceResponseAsync(deactivationRequest), serviceCallback);
    }

    /**
     * Dactivate Many - Content.
     *
     * @param deactivationRequest The deactivation request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deactivateManyAsync(ContentDeactivationRequest deactivationRequest) {
        return deactivateManyWithServiceResponseAsync(deactivationRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Dactivate Many - Content.
     *
     * @param deactivationRequest The deactivation request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deactivateManyWithServiceResponseAsync(ContentDeactivationRequest deactivationRequest) {
        if (deactivationRequest == null) {
            throw new IllegalArgumentException("Parameter deactivationRequest is required and cannot be null.");
        }
        Validator.validate(deactivationRequest);
        return service.deactivateMany(deactivationRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deactivateManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deactivateManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Reactivate Many - Content.
     * The reactivation multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param reactivationRequest The content reactivation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object reactivateMany(ContentReactivationRequest reactivationRequest) {
        return reactivateManyWithServiceResponseAsync(reactivationRequest).toBlocking().single().body();
    }

    /**
     * Reactivate Many - Content.
     * The reactivation multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param reactivationRequest The content reactivation request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> reactivateManyAsync(ContentReactivationRequest reactivationRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(reactivateManyWithServiceResponseAsync(reactivationRequest), serviceCallback);
    }

    /**
     * Reactivate Many - Content.
     * The reactivation multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param reactivationRequest The content reactivation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> reactivateManyAsync(ContentReactivationRequest reactivationRequest) {
        return reactivateManyWithServiceResponseAsync(reactivationRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Reactivate Many - Content.
     * The reactivation multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param reactivationRequest The content reactivation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> reactivateManyWithServiceResponseAsync(ContentReactivationRequest reactivationRequest) {
        if (reactivationRequest == null) {
            throw new IllegalArgumentException("Parameter reactivationRequest is required and cannot be null.");
        }
        Validator.validate(reactivationRequest);
        return service.reactivateMany(reactivationRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = reactivateManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> reactivateManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update Many - Metadata.
     * The metadata update of multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateMetadataMany(ContentsMetadataUpdateRequest updateRequest) {
        return updateMetadataManyWithServiceResponseAsync(updateRequest).toBlocking().single().body();
    }

    /**
     * Update Many - Metadata.
     * The metadata update of multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param updateRequest The metadata update request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateMetadataManyAsync(ContentsMetadataUpdateRequest updateRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateMetadataManyWithServiceResponseAsync(updateRequest), serviceCallback);
    }

    /**
     * Update Many - Metadata.
     * The metadata update of multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateMetadataManyAsync(ContentsMetadataUpdateRequest updateRequest) {
        return updateMetadataManyWithServiceResponseAsync(updateRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Many - Metadata.
     * The metadata update of multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateMetadataManyWithServiceResponseAsync(ContentsMetadataUpdateRequest updateRequest) {
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.updateMetadataMany(updateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateMetadataManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateMetadataManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update by filter - Metadata.
     * Update metadata of multiple contents. A filter must be provided to limit the update to specific contents.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateMetadataByFilter(FilterContentsMetadataUpdateRequest updateRequest) {
        return updateMetadataByFilterWithServiceResponseAsync(updateRequest).toBlocking().single().body();
    }

    /**
     * Update by filter - Metadata.
     * Update metadata of multiple contents. A filter must be provided to limit the update to specific contents.
     *
     * @param updateRequest The metadata update request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateMetadataByFilterAsync(FilterContentsMetadataUpdateRequest updateRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateMetadataByFilterWithServiceResponseAsync(updateRequest), serviceCallback);
    }

    /**
     * Update by filter - Metadata.
     * Update metadata of multiple contents. A filter must be provided to limit the update to specific contents.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateMetadataByFilterAsync(FilterContentsMetadataUpdateRequest updateRequest) {
        return updateMetadataByFilterWithServiceResponseAsync(updateRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update by filter - Metadata.
     * Update metadata of multiple contents. A filter must be provided to limit the update to specific contents.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateMetadataByFilterWithServiceResponseAsync(FilterContentsMetadataUpdateRequest updateRequest) {
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.updateMetadataByFilter(updateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateMetadataByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateMetadataByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update Many - Permissions.
     * The permission update of multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param updateRequest The permissions update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updatePermissionsMany(List<UpdateContentPermissionsRequest> updateRequest) {
        return updatePermissionsManyWithServiceResponseAsync(updateRequest).toBlocking().single().body();
    }

    /**
     * Update Many - Permissions.
     * The permission update of multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param updateRequest The permissions update request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updatePermissionsManyAsync(List<UpdateContentPermissionsRequest> updateRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updatePermissionsManyWithServiceResponseAsync(updateRequest), serviceCallback);
    }

    /**
     * Update Many - Permissions.
     * The permission update of multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param updateRequest The permissions update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updatePermissionsManyAsync(List<UpdateContentPermissionsRequest> updateRequest) {
        return updatePermissionsManyWithServiceResponseAsync(updateRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Many - Permissions.
     * The permission update of multiple contents documents is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param updateRequest The permissions update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updatePermissionsManyWithServiceResponseAsync(List<UpdateContentPermissionsRequest> updateRequest) {
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.updatePermissionsMany(updateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updatePermissionsManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updatePermissionsManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

}
