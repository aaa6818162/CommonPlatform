/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package picturepark.implementation;

import retrofit2.Retrofit;
import picturepark.ListItems;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import picturepark.models.BusinessProcess;
import picturepark.models.BusinessProcessWaitResult;
import picturepark.models.ListItemAggregationRequest;
import picturepark.models.ListItemCreateRequest;
import picturepark.models.ListItemDetail;
import picturepark.models.ListItemFieldsFilterUpdateRequest;
import picturepark.models.ListItemFieldsUpdateRequest;
import picturepark.models.ListItemSearchRequest;
import picturepark.models.ListItemSearchResult;
import picturepark.models.ListItemUpdateRequest;
import picturepark.models.ObjectAggregationResult;
import picturepark.models.PictureparkException;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in ListItems.
 */
public class ListItemsImpl implements ListItems {
    /** The Retrofit service to perform REST calls. */
    private ListItemsService service;
    /** The service client containing this operation class. */
    private WebAPISwaggerspecificationImpl client;

    /**
     * Initializes an instance of ListItems.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ListItemsImpl(Retrofit retrofit, WebAPISwaggerspecificationImpl client) {
        this.service = retrofit.create(ListItemsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for ListItems to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ListItemsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems create" })
        @POST("V1/ListItems")
        Observable<Response<ResponseBody>> create(@Body ListItemCreateRequest listItem, @Query("resolve") boolean resolve, @Query("timeout") Integer timeout, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems createMany" })
        @POST("V1/ListItems/Many")
        Observable<Response<ResponseBody>> createMany(@Body List<ListItemCreateRequest> objects);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems deleteMany" })
        @HTTP(path = "V1/ListItems/Many", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteMany(@Query("ids") String ids);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems updateMany" })
        @PUT("V1/ListItems/Many")
        Observable<Response<ResponseBody>> updateMany(@Body List<ListItemUpdateRequest> objects);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems aggregate" })
        @POST("V1/ListItems/Aggregate")
        Observable<Response<ResponseBody>> aggregate(@Body ListItemAggregationRequest listItemAggregationRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems search" })
        @POST("V1/ListItems/Search")
        Observable<Response<ResponseBody>> search(@Body ListItemSearchRequest listItemSearchRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems delete" })
        @HTTP(path = "V1/ListItems/{ObjectId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("ObjectId") String objectId, @Query("timeout") int timeout);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems get" })
        @GET("V1/ListItems/{ListItemId}")
        Observable<Response<ResponseBody>> get(@Path("ListItemId") String listItemId, @Query("resolve") boolean resolve, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems update" })
        @PUT("V1/ListItems/{ListItemId}")
        Observable<Response<ResponseBody>> update(@Path("ListItemId") String listItemId, @Body ListItemUpdateRequest updateRequest, @Query("resolve") boolean resolve, @Query("timeout") Integer timeout, @Query("patterns") String patterns);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems updateFieldsByFilter" })
        @PUT("V1/ListItems/Many/Fields/Filter")
        Observable<Response<ResponseBody>> updateFieldsByFilter(@Body ListItemFieldsFilterUpdateRequest updateRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems updateFields" })
        @PUT("V1/ListItems/Many/Fields")
        Observable<Response<ResponseBody>> updateFields(@Body ListItemFieldsUpdateRequest updateRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: picturepark.ListItems waitForStates" })
        @GET("V1/ListItems/{ProcessId}/Wait")
        Observable<Response<ResponseBody>> waitForStates(@Path("ProcessId") String processId, @Query("States") String states, @Query("timeout") int timeout);

    }

    /**
     * Create Single.
     * The creation of a single list item is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param listItem List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object create(ListItemCreateRequest listItem, boolean resolve) {
        return createWithServiceResponseAsync(listItem, resolve).toBlocking().single().body();
    }

    /**
     * Create Single.
     * The creation of a single list item is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param listItem List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAsync(ListItemCreateRequest listItem, boolean resolve, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(listItem, resolve), serviceCallback);
    }

    /**
     * Create Single.
     * The creation of a single list item is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param listItem List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAsync(ListItemCreateRequest listItem, boolean resolve) {
        return createWithServiceResponseAsync(listItem, resolve).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create Single.
     * The creation of a single list item is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param listItem List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createWithServiceResponseAsync(ListItemCreateRequest listItem, boolean resolve) {
        if (listItem == null) {
            throw new IllegalArgumentException("Parameter listItem is required and cannot be null.");
        }
        Validator.validate(listItem);
        final Integer timeout = null;
        final List<String> patterns = null;
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.create(listItem, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create Single.
     * The creation of a single list item is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param listItem List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object create(ListItemCreateRequest listItem, boolean resolve, Integer timeout, List<String> patterns) {
        return createWithServiceResponseAsync(listItem, resolve, timeout, patterns).toBlocking().single().body();
    }

    /**
     * Create Single.
     * The creation of a single list item is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param listItem List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAsync(ListItemCreateRequest listItem, boolean resolve, Integer timeout, List<String> patterns, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(listItem, resolve, timeout, patterns), serviceCallback);
    }

    /**
     * Create Single.
     * The creation of a single list item is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param listItem List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAsync(ListItemCreateRequest listItem, boolean resolve, Integer timeout, List<String> patterns) {
        return createWithServiceResponseAsync(listItem, resolve, timeout, patterns).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create Single.
     * The creation of a single list item is executed asynchronous. However, for the specified timeout completion of the creation process is awaited.
     If the creation process is not completed by reaching the specified timeout, the creation process continues, but null is returned.
     *
     * @param listItem List item create request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createWithServiceResponseAsync(ListItemCreateRequest listItem, boolean resolve, Integer timeout, List<String> patterns) {
        if (listItem == null) {
            throw new IllegalArgumentException("Parameter listItem is required and cannot be null.");
        }
        Validator.validate(listItem);
        Validator.validate(patterns);
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.create(listItem, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemDetail>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Create Many.
     * The creation of multiple list items is executed asynchronous. To keep track of the creation progress a business process is returned.
     *
     * @param objects A list of ListItemCreateRequests.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createMany(List<ListItemCreateRequest> objects) {
        return createManyWithServiceResponseAsync(objects).toBlocking().single().body();
    }

    /**
     * Create Many.
     * The creation of multiple list items is executed asynchronous. To keep track of the creation progress a business process is returned.
     *
     * @param objects A list of ListItemCreateRequests.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createManyAsync(List<ListItemCreateRequest> objects, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createManyWithServiceResponseAsync(objects), serviceCallback);
    }

    /**
     * Create Many.
     * The creation of multiple list items is executed asynchronous. To keep track of the creation progress a business process is returned.
     *
     * @param objects A list of ListItemCreateRequests.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createManyAsync(List<ListItemCreateRequest> objects) {
        return createManyWithServiceResponseAsync(objects).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Create Many.
     * The creation of multiple list items is executed asynchronous. To keep track of the creation progress a business process is returned.
     *
     * @param objects A list of ListItemCreateRequests.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createManyWithServiceResponseAsync(List<ListItemCreateRequest> objects) {
        if (objects == null) {
            throw new IllegalArgumentException("Parameter objects is required and cannot be null.");
        }
        Validator.validate(objects);
        return service.createMany(objects)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Delete Many.
     * The deletion of multiple list items is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteMany() {
        return deleteManyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Delete Many.
     * The deletion of multiple list items is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteManyAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteManyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Delete Many.
     * The deletion of multiple list items is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteManyAsync() {
        return deleteManyWithServiceResponseAsync().map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete Many.
     * The deletion of multiple list items is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteManyWithServiceResponseAsync() {
        final List<String> ids = null;
        String idsConverted = this.client.serializerAdapter().serializeList(ids, CollectionFormat.MULTI);
        return service.deleteMany(idsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Delete Many.
     * The deletion of multiple list items is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @param ids The list item id list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteMany(List<String> ids) {
        return deleteManyWithServiceResponseAsync(ids).toBlocking().single().body();
    }

    /**
     * Delete Many.
     * The deletion of multiple list items is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @param ids The list item id list.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteManyAsync(List<String> ids, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteManyWithServiceResponseAsync(ids), serviceCallback);
    }

    /**
     * Delete Many.
     * The deletion of multiple list items is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @param ids The list item id list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteManyAsync(List<String> ids) {
        return deleteManyWithServiceResponseAsync(ids).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete Many.
     * The deletion of multiple list items is executed asynchronous. To keep track of the deletion progress a business process is returned.
     *
     * @param ids The list item id list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteManyWithServiceResponseAsync(List<String> ids) {
        Validator.validate(ids);
        String idsConverted = this.client.serializerAdapter().serializeList(ids, CollectionFormat.MULTI);
        return service.deleteMany(idsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteManyDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update Many.
     * The update of multiple list items is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param objects A list of ListItemUpdateRequests.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateMany(List<ListItemUpdateRequest> objects) {
        return updateManyWithServiceResponseAsync(objects).toBlocking().single().body();
    }

    /**
     * Update Many.
     * The update of multiple list items is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param objects A list of ListItemUpdateRequests.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateManyAsync(List<ListItemUpdateRequest> objects, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateManyWithServiceResponseAsync(objects), serviceCallback);
    }

    /**
     * Update Many.
     * The update of multiple list items is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param objects A list of ListItemUpdateRequests.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateManyAsync(List<ListItemUpdateRequest> objects) {
        return updateManyWithServiceResponseAsync(objects).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Many.
     * The update of multiple list items is executed asynchronous. To keep track of the update progress a business process is returned.
     *
     * @param objects A list of ListItemUpdateRequests.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateManyWithServiceResponseAsync(List<ListItemUpdateRequest> objects) {
        if (objects == null) {
            throw new IllegalArgumentException("Parameter objects is required and cannot be null.");
        }
        Validator.validate(objects);
        return service.updateMany(objects)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateManyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateManyDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Aggregate.
     * Aggregates list items as specified in the aggregation request.
     *
     * @param listItemAggregationRequest The list item aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object aggregate(ListItemAggregationRequest listItemAggregationRequest) {
        return aggregateWithServiceResponseAsync(listItemAggregationRequest).toBlocking().single().body();
    }

    /**
     * Aggregate.
     * Aggregates list items as specified in the aggregation request.
     *
     * @param listItemAggregationRequest The list item aggregation request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> aggregateAsync(ListItemAggregationRequest listItemAggregationRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(aggregateWithServiceResponseAsync(listItemAggregationRequest), serviceCallback);
    }

    /**
     * Aggregate.
     * Aggregates list items as specified in the aggregation request.
     *
     * @param listItemAggregationRequest The list item aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> aggregateAsync(ListItemAggregationRequest listItemAggregationRequest) {
        return aggregateWithServiceResponseAsync(listItemAggregationRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Aggregate.
     * Aggregates list items as specified in the aggregation request.
     *
     * @param listItemAggregationRequest The list item aggregation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> aggregateWithServiceResponseAsync(ListItemAggregationRequest listItemAggregationRequest) {
        if (listItemAggregationRequest == null) {
            throw new IllegalArgumentException("Parameter listItemAggregationRequest is required and cannot be null.");
        }
        Validator.validate(listItemAggregationRequest);
        return service.aggregate(listItemAggregationRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = aggregateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> aggregateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ObjectAggregationResult>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Search.
     * Searches list items as specified in the search request.
     *
     * @param listItemSearchRequest The list item search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object search(ListItemSearchRequest listItemSearchRequest) {
        return searchWithServiceResponseAsync(listItemSearchRequest).toBlocking().single().body();
    }

    /**
     * Search.
     * Searches list items as specified in the search request.
     *
     * @param listItemSearchRequest The list item search request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> searchAsync(ListItemSearchRequest listItemSearchRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(searchWithServiceResponseAsync(listItemSearchRequest), serviceCallback);
    }

    /**
     * Search.
     * Searches list items as specified in the search request.
     *
     * @param listItemSearchRequest The list item search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> searchAsync(ListItemSearchRequest listItemSearchRequest) {
        return searchWithServiceResponseAsync(listItemSearchRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Search.
     * Searches list items as specified in the search request.
     *
     * @param listItemSearchRequest The list item search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> searchWithServiceResponseAsync(ListItemSearchRequest listItemSearchRequest) {
        if (listItemSearchRequest == null) {
            throw new IllegalArgumentException("Parameter listItemSearchRequest is required and cannot be null.");
        }
        Validator.validate(listItemSearchRequest);
        return service.search(listItemSearchRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = searchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> searchDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemSearchResult>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Delete Single.
     * The deletion of a single list item is executed asynchronous. However, for the specified timeout completion of the deletion process is awaited.
     If the deletion process is not completed by reaching the specified timeout, the deletion process continues, but response is sent.
     *
     * @param objectId The list item id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PictureparkException object if successful.
     */
    public PictureparkException delete(String objectId, int timeout) {
        return deleteWithServiceResponseAsync(objectId, timeout).toBlocking().single().body();
    }

    /**
     * Delete Single.
     * The deletion of a single list item is executed asynchronous. However, for the specified timeout completion of the deletion process is awaited.
     If the deletion process is not completed by reaching the specified timeout, the deletion process continues, but response is sent.
     *
     * @param objectId The list item id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PictureparkException> deleteAsync(String objectId, int timeout, final ServiceCallback<PictureparkException> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(objectId, timeout), serviceCallback);
    }

    /**
     * Delete Single.
     * The deletion of a single list item is executed asynchronous. However, for the specified timeout completion of the deletion process is awaited.
     If the deletion process is not completed by reaching the specified timeout, the deletion process continues, but response is sent.
     *
     * @param objectId The list item id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<PictureparkException> deleteAsync(String objectId, int timeout) {
        return deleteWithServiceResponseAsync(objectId, timeout).map(new Func1<ServiceResponse<PictureparkException>, PictureparkException>() {
            @Override
            public PictureparkException call(ServiceResponse<PictureparkException> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete Single.
     * The deletion of a single list item is executed asynchronous. However, for the specified timeout completion of the deletion process is awaited.
     If the deletion process is not completed by reaching the specified timeout, the deletion process continues, but response is sent.
     *
     * @param objectId The list item id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PictureparkException object
     */
    public Observable<ServiceResponse<PictureparkException>> deleteWithServiceResponseAsync(String objectId, int timeout) {
        if (objectId == null) {
            throw new IllegalArgumentException("Parameter objectId is required and cannot be null.");
        }
        return service.delete(objectId, timeout)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PictureparkException>>>() {
                @Override
                public Observable<ServiceResponse<PictureparkException>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PictureparkException> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PictureparkException> deleteDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PictureparkException, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get Single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object get(String listItemId, boolean resolve) {
        return getWithServiceResponseAsync(listItemId, resolve).toBlocking().single().body();
    }

    /**
     * Get Single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAsync(String listItemId, boolean resolve, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(listItemId, resolve), serviceCallback);
    }

    /**
     * Get Single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAsync(String listItemId, boolean resolve) {
        return getWithServiceResponseAsync(listItemId, resolve).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getWithServiceResponseAsync(String listItemId, boolean resolve) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        final List<String> patterns = null;
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.get(listItemId, resolve, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get Single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object get(String listItemId, boolean resolve, List<String> patterns) {
        return getWithServiceResponseAsync(listItemId, resolve, patterns).toBlocking().single().body();
    }

    /**
     * Get Single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAsync(String listItemId, boolean resolve, List<String> patterns, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(listItemId, resolve, patterns), serviceCallback);
    }

    /**
     * Get Single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAsync(String listItemId, boolean resolve, List<String> patterns) {
        return getWithServiceResponseAsync(listItemId, resolve, patterns).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Single.
     *
     * @param listItemId The list item id.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getWithServiceResponseAsync(String listItemId, boolean resolve, List<String> patterns) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        Validator.validate(patterns);
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.get(listItemId, resolve, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemDetail>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update Single.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object update(String listItemId, ListItemUpdateRequest updateRequest, boolean resolve) {
        return updateWithServiceResponseAsync(listItemId, updateRequest, resolve).toBlocking().single().body();
    }

    /**
     * Update Single.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAsync(String listItemId, ListItemUpdateRequest updateRequest, boolean resolve, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(listItemId, updateRequest, resolve), serviceCallback);
    }

    /**
     * Update Single.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAsync(String listItemId, ListItemUpdateRequest updateRequest, boolean resolve) {
        return updateWithServiceResponseAsync(listItemId, updateRequest, resolve).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateWithServiceResponseAsync(String listItemId, ListItemUpdateRequest updateRequest, boolean resolve) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        final Integer timeout = null;
        final List<String> patterns = null;
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.update(listItemId, updateRequest, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update Single.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object update(String listItemId, ListItemUpdateRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns) {
        return updateWithServiceResponseAsync(listItemId, updateRequest, resolve, timeout, patterns).toBlocking().single().body();
    }

    /**
     * Update Single.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAsync(String listItemId, ListItemUpdateRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(listItemId, updateRequest, resolve, timeout, patterns), serviceCallback);
    }

    /**
     * Update Single.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAsync(String listItemId, ListItemUpdateRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns) {
        return updateWithServiceResponseAsync(listItemId, updateRequest, resolve, timeout, patterns).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update Single.
     *
     * @param listItemId The list item id.
     * @param updateRequest The list item update request.
     * @param resolve Resolves the data of referenced list items into the list item's content.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateWithServiceResponseAsync(String listItemId, ListItemUpdateRequest updateRequest, boolean resolve, Integer timeout, List<String> patterns) {
        if (listItemId == null) {
            throw new IllegalArgumentException("Parameter listItemId is required and cannot be null.");
        }
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        Validator.validate(patterns);
        String patternsConverted = this.client.serializerAdapter().serializeList(patterns, CollectionFormat.MULTI);
        return service.update(listItemId, updateRequest, resolve, timeout, patternsConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListItemDetail>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update by filter - Fields.
     * Update fields of multiple list items. A filter must be provided to limit the update to specific list items.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateFieldsByFilter(ListItemFieldsFilterUpdateRequest updateRequest) {
        return updateFieldsByFilterWithServiceResponseAsync(updateRequest).toBlocking().single().body();
    }

    /**
     * Update by filter - Fields.
     * Update fields of multiple list items. A filter must be provided to limit the update to specific list items.
     *
     * @param updateRequest The metadata update request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateFieldsByFilterAsync(ListItemFieldsFilterUpdateRequest updateRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateFieldsByFilterWithServiceResponseAsync(updateRequest), serviceCallback);
    }

    /**
     * Update by filter - Fields.
     * Update fields of multiple list items. A filter must be provided to limit the update to specific list items.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateFieldsByFilterAsync(ListItemFieldsFilterUpdateRequest updateRequest) {
        return updateFieldsByFilterWithServiceResponseAsync(updateRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update by filter - Fields.
     * Update fields of multiple list items. A filter must be provided to limit the update to specific list items.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateFieldsByFilterWithServiceResponseAsync(ListItemFieldsFilterUpdateRequest updateRequest) {
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.updateFieldsByFilter(updateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateFieldsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateFieldsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update - Fields.
     * Update fields of multiple list items. A list of listItemIds must be provided to limit the update to specific list items.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateFields(ListItemFieldsUpdateRequest updateRequest) {
        return updateFieldsWithServiceResponseAsync(updateRequest).toBlocking().single().body();
    }

    /**
     * Update - Fields.
     * Update fields of multiple list items. A list of listItemIds must be provided to limit the update to specific list items.
     *
     * @param updateRequest The metadata update request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateFieldsAsync(ListItemFieldsUpdateRequest updateRequest, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateFieldsWithServiceResponseAsync(updateRequest), serviceCallback);
    }

    /**
     * Update - Fields.
     * Update fields of multiple list items. A list of listItemIds must be provided to limit the update to specific list items.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateFieldsAsync(ListItemFieldsUpdateRequest updateRequest) {
        return updateFieldsWithServiceResponseAsync(updateRequest).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Update - Fields.
     * Update fields of multiple list items. A list of listItemIds must be provided to limit the update to specific list items.
     *
     * @param updateRequest The metadata update request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateFieldsWithServiceResponseAsync(ListItemFieldsUpdateRequest updateRequest) {
        if (updateRequest == null) {
            throw new IllegalArgumentException("Parameter updateRequest is required and cannot be null.");
        }
        Validator.validate(updateRequest);
        return service.updateFields(updateRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateFieldsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateFieldsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcess>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Wait For States.
     * Waits for any specified business process states to be hit. If the timeout is reached, the wait process will be stopped and the wait result returned.
     *
     * @param processId The business process id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object waitForStates(String processId, int timeout) {
        return waitForStatesWithServiceResponseAsync(processId, timeout).toBlocking().single().body();
    }

    /**
     * Wait For States.
     * Waits for any specified business process states to be hit. If the timeout is reached, the wait process will be stopped and the wait result returned.
     *
     * @param processId The business process id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> waitForStatesAsync(String processId, int timeout, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(waitForStatesWithServiceResponseAsync(processId, timeout), serviceCallback);
    }

    /**
     * Wait For States.
     * Waits for any specified business process states to be hit. If the timeout is reached, the wait process will be stopped and the wait result returned.
     *
     * @param processId The business process id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> waitForStatesAsync(String processId, int timeout) {
        return waitForStatesWithServiceResponseAsync(processId, timeout).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Wait For States.
     * Waits for any specified business process states to be hit. If the timeout is reached, the wait process will be stopped and the wait result returned.
     *
     * @param processId The business process id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> waitForStatesWithServiceResponseAsync(String processId, int timeout) {
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        final List<String> states = null;
        String statesConverted = this.client.serializerAdapter().serializeList(states, CollectionFormat.MULTI);
        return service.waitForStates(processId, statesConverted, timeout)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = waitForStatesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Wait For States.
     * Waits for any specified business process states to be hit. If the timeout is reached, the wait process will be stopped and the wait result returned.
     *
     * @param processId The business process id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param states Comma-separated list of business process states to wait for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object waitForStates(String processId, int timeout, List<String> states) {
        return waitForStatesWithServiceResponseAsync(processId, timeout, states).toBlocking().single().body();
    }

    /**
     * Wait For States.
     * Waits for any specified business process states to be hit. If the timeout is reached, the wait process will be stopped and the wait result returned.
     *
     * @param processId The business process id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param states Comma-separated list of business process states to wait for.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> waitForStatesAsync(String processId, int timeout, List<String> states, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(waitForStatesWithServiceResponseAsync(processId, timeout, states), serviceCallback);
    }

    /**
     * Wait For States.
     * Waits for any specified business process states to be hit. If the timeout is reached, the wait process will be stopped and the wait result returned.
     *
     * @param processId The business process id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param states Comma-separated list of business process states to wait for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> waitForStatesAsync(String processId, int timeout, List<String> states) {
        return waitForStatesWithServiceResponseAsync(processId, timeout, states).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Wait For States.
     * Waits for any specified business process states to be hit. If the timeout is reached, the wait process will be stopped and the wait result returned.
     *
     * @param processId The business process id.
     * @param timeout Maximum time in milliseconds to wait for the business process completed state.
     * @param states Comma-separated list of business process states to wait for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> waitForStatesWithServiceResponseAsync(String processId, int timeout, List<String> states) {
        if (processId == null) {
            throw new IllegalArgumentException("Parameter processId is required and cannot be null.");
        }
        Validator.validate(states);
        String statesConverted = this.client.serializerAdapter().serializeList(states, CollectionFormat.MULTI);
        return service.waitForStates(processId, statesConverted, timeout)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = waitForStatesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> waitForStatesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BusinessProcessWaitResult>() { }.getType())
                .register(500, new TypeToken<PictureparkException>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .build(response);
    }

}
